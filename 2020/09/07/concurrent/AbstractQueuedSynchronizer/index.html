<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="J.U.C,源码,">










<meta name="description" content="AbstractQueuedSynchronizer 源码学习">
<meta name="keywords" content="J.U.C,源码">
<meta property="og:type" content="article">
<meta property="og:title" content="AbstractQueuedSynchronizer">
<meta property="og:url" content="http://blog.intersico.com/2020/09/07/concurrent/AbstractQueuedSynchronizer/index.html">
<meta property="og:site_name" content="Every Day">
<meta property="og:description" content="AbstractQueuedSynchronizer 源码学习">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://blog.intersico.com/2020/09/07/concurrent/AbstractQueuedSynchronizer/head.jpg">
<meta property="og:image" content="http://blog.intersico.com/2020/09/07/concurrent/AbstractQueuedSynchronizer/node.jpg">
<meta property="og:image" content="http://blog.intersico.com/2020/09/07/concurrent/AbstractQueuedSynchronizer/condition_queue.jpg">
<meta property="og:image" content="http://blog.intersico.com/2020/09/07/concurrent/AbstractQueuedSynchronizer/sync_queue.jpg">
<meta property="og:updated_time" content="2020-09-10T04:45:54.074Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AbstractQueuedSynchronizer">
<meta name="twitter:description" content="AbstractQueuedSynchronizer 源码学习">
<meta name="twitter:image" content="http://blog.intersico.com/2020/09/07/concurrent/AbstractQueuedSynchronizer/head.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.intersico.com/2020/09/07/concurrent/AbstractQueuedSynchronizer/">





  <title>AbstractQueuedSynchronizer | Every Day</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Every Day</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.intersico.com/2020/09/07/concurrent/AbstractQueuedSynchronizer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="R.D">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Every Day">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">AbstractQueuedSynchronizer</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-07T17:51:12+08:00">
                2020-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/并发/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <img src="/2020/09/07/concurrent/AbstractQueuedSynchronizer/head.jpg">

<p>AbstractQueuedSynchronizer 源码学习</p>
<a id="more"></a>

<blockquote>
<p>本文转载自 <a href="https://www.jianshu.com/p/e7659436538b" target="_blank" rel="noopener">AbstractQueuedSynchronizer 源码分析 (基于Java 8)</a><br>在此感谢文章的作者，对我受益匪浅，此转载仅用于后续查阅与学习。</p>
</blockquote>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>AbstractQueuedSynchronizer 是 JUC 中通过 Sync Queue(<a href="http://blog.intersico.com/2020/09/07/concurrent/CLH%E9%98%9F%E5%88%97%E9%94%81/#more">CLH队列锁</a>, 是 AQS 队列锁的底层模型，AQS 实现了其变体), Condition Queue, volatile 变量 state 提供的控制线程获取统一资源(state)的 Synchronized 工具.</p>
<p>其实 AQS 就是操作系统管程模型的代码层实现，所以先学习管程模型对理解 AQS 有很大的帮助。如果对并发或管程不太熟悉的，可以参考我的这篇文章 : <a href="http://blog.intersico.com/2020/09/07/concurrent/%E5%B9%B6%E5%8F%91%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84/#more">并发到底怎么来的</a></p>
<p>主要特点：</p>
<ul>
<li>内部含有两条 Queue(Sync Queue, Condition Queue)</li>
<li>AQS 内部定义获取锁(acquire), 释放锁(release)的主逻辑, 子类实现响应的模版方法即可</li>
<li>支持共享锁与独占锁两种模式，共享模式时只用 Sync Queue, 独占模式有时只用 Sync Queue, 但若涉及 Condition, 则还有 Condition Queue。</li>
<li>支持包括：不响应中断获取独占锁(acquire), 响应中断获取独占锁(acquireInterruptibly), 超时获取独占锁(tryAcquireNanos); 不响应中断获取共享锁(acquireShared), 响应中断获取共享锁(acquireSharedInterruptibly), 超时获取共享锁(tryAcquireSharedNanos);</li>
</ul>
<p>AQS 是一个并发框架，针对具体的场景，需要子类继承 AQS 并实现以下主要方法：</p>
<p>实现独占：tryAcquire、tryRelease、isHeldExclusively<br>实现共享：tryAcquireShared、tryReleaseShared</p>
<p>一般的lock获取释放流程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># lock 获取</span><br><span class="line">Acquire:</span><br><span class="line"><span class="keyword">while</span>(!tryAcquire(arg))&#123; <span class="comment">// tryAcquire交由子类来实现, 改变 AQS 的state的值</span></span><br><span class="line">   <span class="number">1</span>. tryAcquire 获取lock没成功, 则入 Sync Queue</span><br><span class="line">   <span class="number">2</span>. 若当前节点是 head.next, 则再次尝试获取一下lock (tryAcquire)</span><br><span class="line">   <span class="number">3</span>. 获取 lock 失败, 则改变 前继节点的 waitStatus 的值(变成SIGNAL), 进行 blocked</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># lock 释放</span><br><span class="line">Release:</span><br><span class="line"><span class="keyword">if</span>(tryRelease(arg))&#123; / tryRelease交由子类来实现, 改变 AQS 的state的值</span><br><span class="line">   <span class="number">1</span>. 判断 lock 是否释放彻底</span><br><span class="line">   <span class="number">2</span>. 若自己被标记为SIGNAL, 则唤醒后继节点, 通知其去获取 AQS 中 state 的值</span><br><span class="line">   <span class="number">3</span>. 将自己的 waitStatus 进行复位到 <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个 AQS 分为以下几部分：</p>
<ul>
<li>Node 节点, 用于存放获取线程的节点, 存在于 Sync Queue, Condition Queue, 这些节点主要的区分在于 waitStatus 的值</li>
<li>Condition Queue, 这个队列是用于独占模式中, 只有用到 Condition.awaitXX 时才会将 node加到 tail 上(PS: 在使用 Condition的前提是已经获取 Lock)</li>
<li>Sync Queue, 独占 共享的模式中均会使用到的存放 Node 的 CLH queue(主要特点是, 队列中总有一个 dummy 节点, 后继节点获取锁的条件由前继节点决定, 前继节点在释放 lock 时会唤醒sleep中的后继节点)</li>
<li>ConditionObject, 用于独占的模式, 主要是线程释放lock, 加入 Condition Queue, 并进行相应的 signal 操作</li>
<li>独占的获取lock (acquire, release), 例如 ReentrantLock 就是使用这种</li>
<li>共享的获取lock (acquireShared, releaseShared), 例如 ReeantrantReadWriteLock, Semaphore, CountDownLatch</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="AbstractQueuedSynchronizer-内部类-Node"><a href="#AbstractQueuedSynchronizer-内部类-Node" class="headerlink" title="AbstractQueuedSynchronizer 内部类 Node"></a><strong>AbstractQueuedSynchronizer 内部类 Node</strong></h4><p>Node 节点是代表获取lock的线程, 存在于 Condition Queue, Sync Queue 里面， 而其主要的分别就是 nextWaiter (标记共享还是独占)</p>
<p>waitStatus 标记node的状态，共有5种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。</p>
<ul>
<li>CANCELLED(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li>
<li>SIGNAL(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</li>
<li>CONDITION(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</li>
<li>PROPAGATE(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li>
<li>0：新结点入队时的默认状态。</li>
</ul>
<p><strong>注意</strong> 负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常。</p>
<img src="/2020/09/07/concurrent/AbstractQueuedSynchronizer/node.jpg">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代表 Thread 存在于 Sync Queue 与 Condition Queue 的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** marker to indicate a node is wating in shared mode */</span></span><br><span class="line">    <span class="comment">/** 标识节点是否是 共享的节点(这样的节点只存在于 Sync Queue 里面) */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">/** marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">    <span class="comment">/** 标识节点是 独占模式 */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** waitStatus value yto indicate thread has cancelled */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  CANCELLED 说明节点已经 取消获取 lock 了(一般是由于 interrupt 或 timeout 导致的)</span></span><br><span class="line"><span class="comment">     *  很多时候是在 cancelAcquire 里面进行设置这个标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** waitStatus value to indicate successor;s thread needs unparking */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SIGNAL 标识当前节点的后继节点需要唤醒(PS: 这个通常是在 独占模式下使用, 在共享模式下有时用 PROPAGATE)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点在 Condition Queue 里面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">     * unconditionally propagate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点获取到 lock 或进行 release lock 时, 共享模式的最终状态是 PROPAGATE(PS: 有可能共享模式的节点变成 PROPAGATE 之前就被其后继节点抢占 head 节点, 而从Sync Queue中被踢出掉)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Status field, taking only the values:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment">     *              blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment">     *              unpark its successor when is releases or</span></span><br><span class="line"><span class="comment">     *              cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment">     *              first indicate they need a signal,</span></span><br><span class="line"><span class="comment">     *              then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment">     *              on failure, block</span></span><br><span class="line"><span class="comment">     *  CANCELLED: This node is cancelled due to timeout or interrupt</span></span><br><span class="line"><span class="comment">     *              Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment">     *              a thread with cancelled node never again blocks</span></span><br><span class="line"><span class="comment">     *  CONDITION: This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment">     *              It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment">     *              until transferred, at which time the status</span></span><br><span class="line"><span class="comment">     *              will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment">     *              nothing to do with other uses of the</span></span><br><span class="line"><span class="comment">     *              field, but simplifies mechanics)</span></span><br><span class="line"><span class="comment">     * PROPAGATE: A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment">     *              nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment">     *              doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment">     *              continues, even if other operations hava</span></span><br><span class="line"><span class="comment">     *              since intervened</span></span><br><span class="line"><span class="comment">     * 0:          None of the above(以上)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment">     * Non-negative values mean that a node doesn't need to</span></span><br><span class="line"><span class="comment">     * signal. So, most code doesn't need to check for particular</span></span><br><span class="line"><span class="comment">     * values, just for sign</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The field is initialized to 0 for narmal sync nodes, and</span></span><br><span class="line"><span class="comment">     * CONDITION for condition nodes. It is modified using CAS</span></span><br><span class="line"><span class="comment">     * (or when possible, unconditional volatile writes)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点在 Sync Queue 里面时的前继节点(主要来进行 skip CANCELLED 的节点)</span></span><br><span class="line"><span class="comment">     * 注意: 根据 addWaiter方法:</span></span><br><span class="line"><span class="comment">     *  1. prev节点在队列里面, 则 prev != null 肯定成立</span></span><br><span class="line"><span class="comment">     *  2. prev != null 成立, 不一定 node 就在 Sync Queue 里面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node 在 Sync Queue 里面的后继节点, 主要是在release lock 时进行后继节点的唤醒</span></span><br><span class="line"><span class="comment">     * 而后继节点在前继节点上打上 SIGNAL 标识, 来提醒他 release lock 时需要唤醒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 获取 lock 的引用 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作用分成两种:</span></span><br><span class="line"><span class="comment">     *  1. 在 Sync Queue 里面, nextWaiter用来判断节点是 共享模式, 还是独占模式</span></span><br><span class="line"><span class="comment">     *  2. 在 Condition queue 里面, 指向其后继节点 (Condition queue是一个单向的, 不支持并发的 list)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前节点是否是共享模式 */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 node 的前继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException</span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node()&#123;</span><br><span class="line">        <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 Node 用于 Sync Queue 里面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node(Thread thread, Node mode)&#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 Node 用于 Condition Queue 里面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus)&#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>waitStatus的状态变化:</p>
<ol>
<li>线程刚入 Sync Queue 里面, 发现 独占锁被其他人获取, 则将其前继节点标记为 SIGNAL, 然后再尝试获取一下锁(调用 tryAcquire 方法)</li>
<li>若 调用 tryAcquire 方法获取失败, 则判断一下是否前继节点被标记为 SIGNAL, 若是的话 直接 block(block前会确保前继节点被标记为SIGNAL, 因为前继节点在进行释放锁时根据是否标记为 SIGNAL 来决定唤醒后继节点与否 &lt;- 这是独占的情况下)</li>
<li>前继节点使用完lock, 进行释放, 因为自己被标记为 SIGNAL, 所以唤醒其后继节点</li>
</ol>
<p>waitStatus 变化过程:</p>
<ol>
<li>独占模式下:  0(初始) -&gt; signal(被后继节点标记为release需要唤醒后继节点) -&gt; 0 (等释放好lock, 会恢复到0)</li>
<li>独占模式 + 使用 Condition情况下: 0(初始) -&gt; signal(被后继节点标记为release需要唤醒后继节点) -&gt; 0 (等释放好lock, 会恢复到0)<br>其上可能涉及 中断与超时, 只是多了一个 CANCELLED, 当节点变成 CANCELLED, 后就等着被清除</li>
<li>共享模式下: 0(初始) -&gt; PROPAGATE(获取 lock 或release lock 时) (获取 lock 时会调用 setHeadAndPropagate 来进行 传递式的唤醒后继节点, 直到碰到 独占模式的节点)</li>
<li>共享模式 + 独占模式下: 0(初始) -&gt; signal(被后继节点标记为release需要唤醒后继节点) -&gt; 0 (等释放好lock, 会恢复到0)</li>
</ol>
<h4 id="AbstractQueuedSynchronizer-内部Queue-：Condition-Queue"><a href="#AbstractQueuedSynchronizer-内部Queue-：Condition-Queue" class="headerlink" title="AbstractQueuedSynchronizer 内部Queue ：Condition Queue"></a><strong>AbstractQueuedSynchronizer 内部Queue ：Condition Queue</strong></h4><p>Condition Queue 是一个并发不安全的, 只用于独占模式的队列(PS: 为什么是并发不安全的呢? 主要是在操作 Condition 时, 线程必需获取 独占的 lock, 所以不需要考虑并发的安全问题);<br>而当Node存在于 Condition Queue 里面, 则其只有 waitStatus, thread, nextWaiter 有值, 其他的都是null(其中的 waitStatus 只能是 CONDITION, 0(0 代表node进行转移到 Sync Queue里面, 或被中断/timeout)); 这里有个注意点, 就是 当线程被中断或获取 lock 超时, 则一瞬间 node 会存在于 Condition Queue, Sync Queue 两个队列中.</p>
<img src="/2020/09/07/concurrent/AbstractQueuedSynchronizer/condition_queue.jpg">

<p>节点 Node4, Node5, Node6, Node7 都是调用 Condition.awaitXX 方法 加入 Condition Queue(PS: 加入后会将原来的 lock 释放)</p>
<p><strong>Condition Queue 入队列方法 addConditionWaiter</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a new waiter to wait queue</span></span><br><span class="line"><span class="comment"> * 将当前线程封装成一个 Node 节点 放入大 Condition Queue 里面</span></span><br><span class="line"><span class="comment"> * 大家可以注意到, 下面对 Condition Queue 的操作都没考虑到 并发(Sync Queue 的队列是支持并发操作的), 这是为什么呢? 因为在进行操作 Condition 是当前的线程已经获取了AQS的独占锁, 所以不需要考虑并发的情况</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node t = lastWaiter; <span class="comment">// 1. Condition queue 的尾节点</span></span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out              </span></span><br><span class="line">    <span class="comment">// 2.尾节点已经Cancel, 直接进行清除,</span></span><br><span class="line">    <span class="comment">// 这里有1个问题, 1 何时出现t.waitStatus != Node.CONDITION -&gt; 在对线程进行中断时 ConditionObject -&gt; await -&gt; checkInterruptWhileWaiting -&gt; transferAfterCancelledWait "compareAndSetWaitStatus(node, Node.CONDITION, 0)" &lt;- 导致这种情况一般是 线程中断或 await 超时</span></span><br><span class="line">    <span class="comment">// 一个注意点: 当Condition进行 awiat 超时或被中断时, Condition里面的节点是没有被删除掉的, 需要其他 await 在将线程加入 Condition Queue 时调用addConditionWaiter而进而删除, 或 await 操作差不多结束时, 调用 "node.nextWaiter != null" 进行判断而删除 (PS: 通过 signal 进行唤醒时 node.nextWaiter 会被置空, 而中断和超时时不会)</span></span><br><span class="line">    <span class="keyword">if</span>(t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION)&#123;</span><br><span class="line">        unlinkCancelledWaiters(); <span class="comment">// 3. 调用 unlinkCancelledWaiters 对 "waitStatus != Node.CONDITION" 的节点进行删除(在Condition里面的Node的waitStatus 要么是CONDITION(正常), 要么就是 0 (signal/timeout/interrupt))</span></span><br><span class="line">        t = lastWaiter; <span class="comment">// 4. 获取最新的 lastWaiter</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION); <span class="comment">// 5. 将线程封装成 node 准备放入 Condition Queue 里面</span></span><br><span class="line">    <span class="keyword">if</span>(t == <span class="keyword">null</span>)&#123;</span><br><span class="line">        firstWaiter = node;  <span class="comment">// 6 .Condition Queue 是空的</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        t.nextWaiter = node; <span class="comment">// 7. 最加到 queue 尾部</span></span><br><span class="line">    &#125;</span><br><span class="line">    lastWaiter = node; <span class="comment">// 8. 重新赋值 lastWaiter</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Condition Queue 删除Cancelled节点的方法 unlinkCancelledWaiters</strong></p>
<p>当Node在Condition Queue 中, 若状态不是 CONDITION, 则一定是 被中断或超时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 调用 addConditionWaiter 将线程放入 Condition Queue 里面时 或 awiat 方法获取 差不多结束时 进行清理 Condition queue 里面的因 timeout/interrupt 而还存在的节点</span></span><br><span class="line"><span class="comment"> * 这个删除操作比较巧妙, 其中引入了 trail 节点， 可以理解为traverse整个 Condition Queue 时遇到的最后一个有效的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(t != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Node next = t.nextWaiter; <span class="comment">// 1. 先初始化 next 节点</span></span><br><span class="line">        <span class="keyword">if</span>(t.waitStatus != Node.CONDITION)&#123; <span class="comment">// 2. 节点不有效, 在Condition Queue 里面 Node.waitStatus 只有可能是 CONDITION 或是 0(timeout/interrupt引起的)</span></span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>; <span class="comment">// 3. Node.nextWaiter 置空</span></span><br><span class="line">            <span class="keyword">if</span>(trail == <span class="keyword">null</span>)&#123; <span class="comment">// 4. 一次都没有遇到有效的节点</span></span><br><span class="line">                firstWaiter = next; <span class="comment">// 5. 将 next 赋值给 firstWaiter(此时 next 可能也是无效的, 这只是一个临时处理)</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                trail.nextWaiter = next; <span class="comment">// 6. next 赋值给 trail.nextWaiter, 这一步其实就是删除节点 t</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(next == <span class="keyword">null</span>)&#123; <span class="comment">// 7. next == null 说明 已经 traverse 完了 Condition Queue</span></span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            trail = t; <span class="comment">// 8. 将有效节点赋值给 trail</span></span><br><span class="line">        &#125;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Condition Queue 转移节点的方法 transferForSignal</strong></p>
<p>transferForSignal只有在节点被正常唤醒才调用的正常转移的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 Node 从Condition Queue 转移到 Sync Queue 里面</span></span><br><span class="line"><span class="comment"> * 在调用transferForSignal之前, 会 first.nextWaiter = null;</span></span><br><span class="line"><span class="comment"> * 而我们发现 若节点是因为 timeout / interrupt 进行转移, 则不会进行这步操作; 两种情况的转移都会把 wautStatus 置为 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If cannot change waitStatus, the node has been cancelled</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>(!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))&#123; <span class="comment">// 1. 若 node 已经 cancelled 则失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">     * indicate that thread is (probably) waiting, If cancelled or</span></span><br><span class="line"><span class="comment">     * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">     * case the waitStatus can be transiently and harmlessly wrong)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node p = enq(node);  <span class="comment">// 2. 加入 Sync Queue</span></span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span>(ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))&#123; <span class="comment">// 3. 这里的 ws &gt; 0 指Sync Queue 中node 的前继节点cancelled 了, 所以, 唤醒一下 node ; compareAndSetWaitStatus(p, ws, Node.SIGNAL)失败, 则说明 前继节点已经变成 SIGNAL 或 cancelled, 所以也要 唤醒</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Condition Queue 转移节点的方法 transferAfterCancelledWait</strong></p>
<p>transferAfterCancelledWait 在节点获取lock时被中断或获取超时才调用的转移方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 Condition Queue 中因 timeout/interrupt 而唤醒的节点进行转移</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))&#123; <span class="comment">// 1. 没有 node 没有 cancelled , 直接进行转移 (转移后, Sync Queue , Condition Queue 都会存在 node)</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If we lost out to a signal(), then we can't proceed</span></span><br><span class="line"><span class="comment">     * until it finishes its enq(). Cancelling during an</span></span><br><span class="line"><span class="comment">     * incomplete transfer is both race and transient, so just</span></span><br><span class="line"><span class="comment">     * spin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span>(!isOnSyncQueue(node))&#123; <span class="comment">// 2.这时是其他的线程发送signal,将本线程转移到 Sync Queue 里面的工程中(转移的过程中 waitStatus = 0了, 所以上面的 CAS 操作失败)</span></span><br><span class="line">        Thread.yield();  <span class="comment">// 这里调用 isOnSyncQueue判断是否已经 入Sync Queue 了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AbstractQueuedSynchronizer-内部-Queue-Sync-Queue"><a href="#AbstractQueuedSynchronizer-内部-Queue-Sync-Queue" class="headerlink" title="AbstractQueuedSynchronizer 内部 Queue Sync Queue"></a><strong>AbstractQueuedSynchronizer 内部 Queue Sync Queue</strong></h4><p>Sync Queue 是一个类似于 CLH Queue 的并发安全, 双向, 用于独占和共享两种模式下的 queue.<br>而当 Node 存在于 Sync Queue 时, waitStatus,， prev, next, thread, nextWaiter 均可能有值; waitStatus 可能是 SIGNAL, 0, PROPAGATE, CANCELLED; 当节点不是 head 时一定prev != null(而 node.prev != null 不能说明节点一定存在于 Sync Queue); node.next != null 则 node一定存在于Sync Queue, 而 node存在于 Sync Queue 则 node.next 就不一定 != null; thread 则代表获取 lock 的线程; nextWaiter 用于标示共享还是独占的获取 lock</p>
<img src="/2020/09/07/concurrent/AbstractQueuedSynchronizer/sync_queue.jpg">

<p>这个图代表有个线程获取lock, 而 Node1, Node2, Node3 则在Sync Queue 里面进行等待获取lock(PS: 注意到 dummy Node 的SINGNAL 这是叫获取 lock 的线程在释放lock时通知后继节点的标示)</p>
<p><strong>Sync Queue 节点入Queue方法</strong></p>
<p>这里有个地方需要注意, 就是初始化 head, tail 的节点, 不一定是 head.next, 因为期间可能被其他的线程进行抢占了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前的线程封装成 Node 加入到 Sync Queue 里面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span></span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);      <span class="comment">// 1. 封装 Node</span></span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span>(pred != <span class="keyword">null</span>)&#123; <span class="comment">// 2. pred != null -&gt; 队列中已经有节点, 直接 CAS 到尾节点</span></span><br><span class="line">        node.prev = pred; <span class="comment">// 3. 先设置 Node.pre = pred (PS: 则当一个 node在Sync Queue里面时  node.prev 一定 != null(除 dummy node), 但是 node.prev != null 不能说明其在 Sync Queue 里面, 因为现在的CAS可能失败 )</span></span><br><span class="line">        <span class="keyword">if</span>(compareAndSetTail(pred, node))&#123; <span class="comment">// 4. CAS node 到 tail</span></span><br><span class="line">            pred.next = node; <span class="comment">// 5. CAS 成功, 将 pred.next = node (PS: 说明 node.next != null -&gt; 则 node 一定在 Sync Queue, 但若 node 在Sync Queue 里面不一定 node.next != null)</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node); <span class="comment">// 6. 队列为空, 调用 enq 入队列</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个插入会检测head tail 的初始化, 必要的话会初始化一个 dummy 节点, 这个和 ConcurrentLinkedQueue 一样的</span></span><br><span class="line"><span class="comment"> * Insert node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node's predecessor 返回的是前继节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将节点 node 加入队列</span></span><br><span class="line"><span class="comment"> * 这里有个注意点</span></span><br><span class="line"><span class="comment"> * 情况:</span></span><br><span class="line"><span class="comment"> *      1. 首先 queue是空的</span></span><br><span class="line"><span class="comment"> *      2. 初始化一个 dummy 节点</span></span><br><span class="line"><span class="comment"> *      3. 这时再在tail后面添加节点(这一步可能失败, 可能发生竞争被其他的线程抢占)</span></span><br><span class="line"><span class="comment"> *  这里为什么要加入一个 dummy 节点呢?</span></span><br><span class="line"><span class="comment"> *      这里的 Sync Queue 是CLH lock的一个变种, 线程节点 node 能否获取lock的判断通过其前继节点</span></span><br><span class="line"><span class="comment"> *      而且这里在当前节点想获取lock时通常给前继节点 打上 signal 的标识(表示前继节点释放lock需要通知我来获取lock)</span></span><br><span class="line"><span class="comment"> *      若这里不清楚的同学, 请先看看 CLH lock的资料 (这是理解 AQS 的基础)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="keyword">null</span>)&#123; <span class="comment">// Must initialize // 1. 队列为空 初始化一个 dummy 节点 其实和 ConcurrentLinkedQueue 一样</span></span><br><span class="line">            <span class="keyword">if</span>(compareAndSetHead(<span class="keyword">new</span> Node()))&#123;  <span class="comment">// 2. 初始化 head 与 tail (这个CAS成功后, head 就有值了, 详情将 Unsafe 操作)</span></span><br><span class="line">                tail = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.prev = t; <span class="comment">// 3. 先设置 Node.pre = pred (PS: 则当一个 node在Sync Queue里面时  node.prev 一定 != null, 但是 node.prev != null 不能说明其在 Sync Queue 里面, 因为现在的CAS可能失败 )</span></span><br><span class="line">            <span class="keyword">if</span>(compareAndSetTail(t, node))&#123; <span class="comment">// 4. CAS node 到 tail</span></span><br><span class="line">                t.next = node; <span class="comment">// 5. CAS 成功, 将 pred.next = node (PS: 说明 node.next != null -&gt; 则 node 一定在 Sync Queue, 但若 node 在Sync Queue 里面不一定 node.next != null)</span></span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Sync Queue 节点出Queue方法</strong></p>
<p>这里的出Queue的方法其实有两个</p>
<ol>
<li>新节点获取lock, 调用setHead抢占head, 并且剔除原head</li>
<li>节点因被中断或获取超时而进行 cancelled, 最后被剔除</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 head 节点(在独占模式没有并发的可能, 当共享的模式有可能)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>; <span class="comment">// 清除线程引用</span></span><br><span class="line">    node.prev = <span class="keyword">null</span>; <span class="comment">// 清除原来 head 的引用 &lt;- 都是 help GC</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cancels an ongoing attempt to acquire.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除因中断/超时而放弃获取lock的线程节点(此时节点在 Sync Queue 里面)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node.thread = <span class="keyword">null</span>;                 <span class="comment">// 1. 线程引用清空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)       <span class="comment">// 2.  若前继节点是 CANCELLED 的, 则也一并清除</span></span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    Node predNext = pred.next;         <span class="comment">// 3. 这里的 predNext也是需要清除的(只不过在清除时的 CAS 操作需要 它)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED; <span class="comment">// 4. 标识节点需要清除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; <span class="comment">// 5. 若需要清除额节点是尾节点, 则直接 CAS pred为尾节点</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);    <span class="comment">// 6. 删除节点predNext</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred's next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">                ((ws = pred.waitStatus) == Node.SIGNAL || <span class="comment">// 7. 后继节点需要唤醒(但这里的后继节点predNext已经 CANCELLED 了)</span></span><br><span class="line">                        (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; <span class="comment">// 8. 将 pred 标识为 SIGNAL</span></span><br><span class="line">                pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 8. next.waitStatus &lt;= 0 表示 next 是个一个想要获取lock的节点</span></span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node); <span class="comment">// 若 pred 是头节点, 则此刻可能有节点刚刚进入 queue ,所以进行一下唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractQueuedSynchronizer 独占的获取lock</strong></p>
<p>独占方式获取lock主要流程：</p>
<ol>
<li>调用 tryAcquire 尝试性的获取锁(一般都是由子类实现), 成功的话直接返回</li>
<li>tryAcquire 调用获取失败, 将当前的线程封装成 Node 加入到 Sync Queue 里面(调用addWaiter), 等待获取 signal 信号</li>
<li>调用 acquireQueued 进行自旋的方式获取锁(有可能会 repeatedly blocking and unblocking)</li>
<li>根据acquireQueued的返回值判断在获取lock的过程中是否被中断, 若被中断, 则自己再中断一下(selfInterrupt), 若是响应中断的则直接抛出异常</li>
</ol>
<p>独占方式获取lock主要分成下面3类:</p>
<ol>
<li>acquire 不响应中断的获取lock, 这里的不响应中断指的是线程被中断后会被唤醒, 并且继续获取lock,在方法返回时, 根据刚才的获取过程是否被中断来决定是否要自己中断一下(方法 selfInterrupt)</li>
<li>doAcquireInterruptibly 响应中断的获取 lock, 这里的响应中断, 指在线程获取 lock 过程中若被中断, 则直接抛出异常</li>
<li>doAcquireNanos 响应中断及超时的获取 lock, 当线程被中断, 或获取超时, 则直接抛出异常, 获取失败</li>
</ol>
<p><strong>AbstractQueuedSynchronizer 独占的获取lock 方法 acquire</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** acquire 是用于获取锁的最常用的模式</span></span><br><span class="line"><span class="comment"> * 步骤</span></span><br><span class="line"><span class="comment"> *      1. 调用 tryAcquire 尝试性的获取锁(一般都是又子类实现), 成功的话直接返回</span></span><br><span class="line"><span class="comment"> *      2. tryAcquire 调用获取失败, 将当前的线程封装成 Node 加入到 Sync Queue 里面(调用addWaiter), 等待获取 signal 信号</span></span><br><span class="line"><span class="comment"> *      3. 调用 acquireQueued 进行自旋的方式获取锁(有可能会 repeatedly blocking and unblocking)</span></span><br><span class="line"><span class="comment"> *      4. 根据acquireQueued的返回值判断在获取lock的过程中是否被中断, 若被中断, 则自己再中断一下(selfInterrupt)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tryAcquire(arg)&amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&#123;</span><br><span class="line">        selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractQueuedSynchronizer 循环获取lock 方法 acquireQueued</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不支持中断的获取锁</span></span><br><span class="line"><span class="comment"> * 主逻辑:</span></span><br><span class="line"><span class="comment"> *  1. 当当前节点的前继节点是head节点时先 tryAcquire获取一下锁, 成功的话设置新 head, 返回</span></span><br><span class="line"><span class="comment"> *  2. 第一步不成功, 检测是否需要sleep, 需要的话就 sleep, 等待前继节点在释放lock时唤醒 或通过中断来唤醒</span></span><br><span class="line"><span class="comment"> *  3. 整个过程可能需要blocking nonblocking 几次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();      <span class="comment">// 1. 获取当前节点的前继节点 (当一个n在 Sync Queue 里面, 并且没有获取 lock 的 node 的前继节点不可能是 null)</span></span><br><span class="line">            <span class="keyword">if</span>(p == head &amp;&amp; tryAcquire(arg))&#123;       <span class="comment">// 2. 判断前继节点是否是head节点(前继节点是head, 存在两种情况 (1) 前继节点现在占用 lock (2)前继节点是个空节点, 已经释放 lock, node 现在有机会获取 lock); 则再次调用 tryAcquire尝试获取一下</span></span><br><span class="line">                setHead(node);                       <span class="comment">// 3. 获取 lock 成功, 直接设置 新head(原来的head可能就直接被回收)</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC          // help gc</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;                <span class="comment">// 4. 返回在整个获取的过程中是否被中断过 ; 但这又有什么用呢? 若整个过程中被中断过, 则最后我在 自我中断一下 (selfInterrupt), 因为外面的函数可能需要知道整个过程是否被中断过</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 5. 调用 shouldParkAfterFailedAcquire 判断是否需要中断(这里可能会一开始 返回 false, 但在此进去后直接返回 true(主要和前继节点的状态是否是 signal))</span></span><br><span class="line">                    parkAndCheckInterrupt())&#123;      <span class="comment">// 6. 现在lock还是被其他线程占用 那就睡一会, 返回值判断是否这次线程的唤醒是被中断唤醒</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)&#123;                             <span class="comment">// 7. 在整个获取中出错</span></span><br><span class="line">            cancelAcquire(node);                <span class="comment">// 8. 清除 node 节点(清除的过程是先给 node 打上 CANCELLED标志, 然后再删除)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shouldParkAfterFailedAcquire(Node, Node)</p>
<p><strong>shouldParkAfterFailedAcquire(Node, Node)</strong></p>
<p>此方法主要用于检查状态，看看自己是否真的可以去休息了，万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">//拿到前驱的状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">//如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。</span></span><br><span class="line"><span class="comment">         * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。</p>
<p><strong>parkAndCheckInterrupt()</strong></p>
<p>如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     LockSupport.park(<span class="keyword">this</span>);<span class="comment">//调用park()使线程进入waiting状态</span></span><br><span class="line">     <span class="keyword">return</span> Thread.interrupted();<span class="comment">//如果被唤醒，查看自己是不是被中断的。</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。 </p>
<p><strong>AbstractQueuedSynchronizer 支持中断获取lock 方法 doAcquireInterruptibly</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquire in exclusive interruptible mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);  <span class="comment">// 1. 将当前的线程封装成 Node 加入到 Sync Queue 里面</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 2. 获取当前节点的前继节点 (当一个n在 Sync Queue 里面, 并且没有获取 lock 的 node 的前继节点不可能是 null)</span></span><br><span class="line">            <span class="keyword">if</span>(p == head &amp;&amp; tryAcquire(arg))&#123;  <span class="comment">// 3. 判断前继节点是否是head节点(前继节点是head, 存在两种情况 (1) 前继节点现在占用 lock (2)前继节点是个空节点, 已经释放 lock, node 现在有机会获取 lock); 则再次调用 tryAcquire尝试获取一下</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 4. 调用 shouldParkAfterFailedAcquire 判断是否需要中断(这里可能会一开始 返回 false, 但在此进去后直接返回 true(主要和前继节点的状态是否是 signal))</span></span><br><span class="line">                    parkAndCheckInterrupt())&#123;           <span class="comment">// 5. 现在lock还是被其他线程占用 那就睡一会, 返回值判断是否这次线程的唤醒是被中断唤醒</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();       <span class="comment">// 6. 线程此时唤醒是通过线程中断, 则直接抛异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)&#123;                 <span class="comment">// 7. 在整个获取中出错(比如线程中断)</span></span><br><span class="line">            cancelAcquire(node);    <span class="comment">// 8. 清除 node 节点(清除的过程是先给 node 打上 CANCELLED标志, 然后再删除)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractQueuedSynchronizer 支持超时&amp;中断获取lock 方法 doAcquireNanos(int arg, long nanosTimeout)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquire in exclusive timed mode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanosTimeout max wait time</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if acquired</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nanosTimeout &lt;= <span class="number">0L</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout; <span class="comment">// 0. 计算截至时间</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);  <span class="comment">// 1. 将当前的线程封装成 Node 加入到 Sync Queue 里面</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 2. 获取当前节点的前继节点 (当一个n在 Sync Queue 里面, 并且没有获取 lock 的 node 的前继节点不可能是 null)</span></span><br><span class="line">            <span class="keyword">if</span>(p == head &amp;&amp; tryAcquire(arg))&#123;  <span class="comment">// 3. 判断前继节点是否是head节点(前继节点是head, 存在两种情况 (1) 前继节点现在占用 lock (2)前继节点是个空节点, 已经释放 lock, node 现在有机会获取 lock); 则再次调用 tryAcquire尝试获取一下</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime(); <span class="comment">// 4. 计算还剩余的时间</span></span><br><span class="line">            <span class="keyword">if</span>(nanosTimeout &lt;= <span class="number">0L</span>)&#123;                      <span class="comment">// 5. 时间超时, 直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 6. 调用 shouldParkAfterFailedAcquire 判断是否需要中断(这里可能会一开始 返回 false, 但在此进去后直接返回 true(主要和前继节点的状态是否是 signal))</span></span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)&#123; <span class="comment">// 7. 若没超时, 并且大于spinForTimeoutThreshold, 则线程 sleep(小于spinForTimeoutThreshold, 则直接自旋, 因为效率更高 调用 LockSupport 是需要开销的)</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Thread.interrupted())&#123;                           <span class="comment">// 8. 线程此时唤醒是通过线程中断, 则直接抛异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)&#123;                 <span class="comment">// 9. 在整个获取中出错(比如线程中断/超时)</span></span><br><span class="line">            cancelAcquire(node);    <span class="comment">// 10. 清除 node 节点(清除的过程是先给 node 打上 CANCELLED标志, 然后再删除)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractQueuedSynchronizer 释放lock方法</strong></p>
<p>整个释放 lock 流程</p>
<ol>
<li>调用子类的 tryRelease 方法释放获取的资源</li>
<li>判断是否完全释放lock(这里有 lock 重复获取的情况)</li>
<li>判断是否有后继节点需要唤醒, 需要的话调用unparkSuccessor进行唤醒</li>
</ol>
<p>看代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releasing in exclusive mode. Implemented by unblocking one or</span></span><br><span class="line"><span class="comment"> * more threads if &#123;<span class="doctag">@link</span> #tryRelease(int)&#125; returns true.</span></span><br><span class="line"><span class="comment"> * This method can be used to implement method &#123;<span class="doctag">@link</span> "Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the release argument. This value is conveyed to</span></span><br><span class="line"><span class="comment"> *            &#123;<span class="doctag">@link</span> #tryRelease(int)&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *            can represent anything you like.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease(int)&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tryRelease(arg))&#123;   <span class="comment">// 1. 调用子类, 若完全释放好, 则返回true(这里有lock重复获取)</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span>(h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)&#123; <span class="comment">// 2. h.waitStatus !=0 其实就是 h.waitStatus &lt; 0 后继节点需要唤醒</span></span><br><span class="line">            unparkSuccessor(h);   <span class="comment">// 3. 唤醒后继节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up node's successor, if one exists.</span></span><br><span class="line"><span class="comment"> * 唤醒 node 的后继节点</span></span><br><span class="line"><span class="comment"> * 这里有个注意点: 唤醒时会将当前node的标识归位为 0</span></span><br><span class="line"><span class="comment"> * 等于当前节点标识位 的流转过程: 0(刚加入queue) -&gt; signal (被后继节点要求在释放时需要唤醒) -&gt; 0 (进行唤醒后继节点)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"unparkSuccessor node:"</span> + node + Thread.currentThread().getName());</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);       <span class="comment">// 1. 清除前继节点的标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    logger.info(<span class="string">"unparkSuccessor s:"</span> + node + Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;         <span class="comment">// 2. 这里若在 Sync Queue 里面存在想要获取 lock 的节点,则一定需要唤醒一下(跳过取消的节点)　（PS: s == null发生在共享模式的竞争释放资源）</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)              <span class="comment">// 3. 找到 queue 里面最前面想要获取 Lock 的节点</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(<span class="string">"unparkSuccessor s:"</span>+s);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractQueuedSynchronizer 获取共享lock</strong></p>
<p>共享方式获取lock流程:</p>
<ol>
<li>调用 tryAcquireShared 尝试性的获取锁(一般都是由子类实现), 成功的话直接返回</li>
<li>tryAcquireShared 调用获取失败, 将当前的线程封装成 Node 加入到 Sync Queue 里面(调用addWaiter), 等待获取 signal 信号</li>
<li>在 Sync Queue 里面进行自旋的方式获取锁(有可能会 repeatedly blocking and unblocking</li>
<li>当获取失败, 则判断是否可以 block(block的前提是前继节点被打上 SIGNAL 标示)</li>
<li>共享与独占获取lock的区别主要在于 在共享方式下获取 lock 成功会判断是否需要继续唤醒下面的继续获取共享lock的节点(及方法 doReleaseShared)</li>
</ol>
<p>共享方式获取lock主要分成下面3类:</p>
<ol>
<li>acquireShared 不响应中断的获取lock, 这里的不响应中断指的是线程被中断后会被唤醒, 并且继续获取lock,在方法返回时, 根据刚才的获取过程是否被中断来决定是否要自己中断一下(方法 selfInterrupt)</li>
<li>doAcquireSharedInterruptibly 响应中断的获取 lock, 这里的响应中断, 指在线程获取 lock 过程中若被中断, 则直接抛出异常</li>
<li>doAcquireSharedNanos 响应中断及超时的获取 lock, 当线程被中断, 或获取超时, 则直接抛出异常, 获取失败</li>
</ol>
<p><strong>AbstractQueuedSynchronizer 获取共享lock 方法 acquireShared</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 共享 lock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tryAcquireShared(arg) &lt; <span class="number">0</span>)&#123;  <span class="comment">// 1. 调用子类, 获取共享 lock  返回 &lt; 0, 表示失败</span></span><br><span class="line">        doAcquireShared(arg);       <span class="comment">// 2. 调用 doAcquireShared 当前 线程加入 Sync Queue 里面, 等待获取 lock</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractQueuedSynchronizer 获取共享lock 方法 doAcquireShared</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquire in shared uninterruptible mode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);       <span class="comment">// 1. 将当前的线程封装成 Node 加入到 Sync Queue 里面</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();      <span class="comment">// 2. 获取当前节点的前继节点 (当一个n在 Sync Queue 里面, 并且没有获取 lock 的 node 的前继节点不可能是 null)</span></span><br><span class="line">            <span class="keyword">if</span>(p == head)&#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);      <span class="comment">// 3. 判断前继节点是否是head节点(前继节点是head, 存在两种情况 (1) 前继节点现在占用 lock (2)前继节点是个空节点, 已经释放 lock, node 现在有机会获取 lock); 则再次调用 tryAcquireShared 尝试获取一下</span></span><br><span class="line">                <span class="keyword">if</span>(r &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);   <span class="comment">// 4. 获取 lock 成功, 设置新的 head, 并唤醒后继获取  readLock 的节点</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span>(interrupted)&#123;               <span class="comment">// 5. 在获取 lock 时, 被中断过, 则自己再自我中断一下(外面的函数可能需要这个参数)</span></span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 6. 调用 shouldParkAfterFailedAcquire 判断是否需要中断(这里可能会一开始 返回 false, 但在此进去后直接返回 true(主要和前继节点的状态是否是 signal))</span></span><br><span class="line">                    parkAndCheckInterrupt())&#123;           <span class="comment">// 7. 现在lock还是被其他线程占用 那就睡一会, 返回值判断是否这次线程的唤醒是被中断唤醒</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)&#123;             <span class="comment">// 8. 在整个获取中出错(比如线程中断/超时)</span></span><br><span class="line">            cancelAcquire(node);  <span class="comment">// 9. 清除 node 节点(清除的过程是先给 node 打上 CANCELLED标志, 然后再删除)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractQueuedSynchronizer 获取共享lock 方法 doAcquireSharedInterruptibly</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquire in shared interruptible mode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);            <span class="comment">// 1. 将当前的线程封装成 Node 加入到 Sync Queue 里面</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();          <span class="comment">// 2. 获取当前节点的前继节点 (当一个n在 Sync Queue 里面, 并且没有获取 lock 的 node 的前继节点不可能是 null)</span></span><br><span class="line">            <span class="keyword">if</span>(p == head)&#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);          <span class="comment">// 3. 判断前继节点是否是head节点(前继节点是head, 存在两种情况 (1) 前继节点现在占用 lock (2)前继节点是个空节点, 已经释放 lock, node 现在有机会获取 lock); 则再次调用 tryAcquireShared 尝试获取一下</span></span><br><span class="line">                <span class="keyword">if</span>(r &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);       <span class="comment">// 4. 获取 lock 成功, 设置新的 head, 并唤醒后继获取  readLock 的节点</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">// 5. 调用 shouldParkAfterFailedAcquire 判断是否需要中断(这里可能会一开始 返回 false, 但在此进去后直接返回 true(主要和前继节点的状态是否是 signal))</span></span><br><span class="line">                    parkAndCheckInterrupt())&#123;           <span class="comment">// 6. 现在lock还是被其他线程占用 那就睡一会, 返回值判断是否这次线程的唤醒是被中断唤醒</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();     <span class="comment">// 7. 若此次唤醒是 通过线程中断, 则直接抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)&#123;              <span class="comment">// 8. 在整个获取中出错(比如线程中断/超时)</span></span><br><span class="line">            cancelAcquire(node); <span class="comment">// 9. 清除 node 节点(清除的过程是先给 node 打上 CANCELLED标志, 然后再删除)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractQueuedSynchronizer 获取共享lock 方法 doAcquireSharedNanos</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquire in shared timed mode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanosTimeout max wait time</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if acquired</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;  <span class="comment">// 0. 计算超时的时间</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);               <span class="comment">// 1. 将当前的线程封装成 Node 加入到 Sync Queue 里面</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();          <span class="comment">// 2. 获取当前节点的前继节点 (当一个n在 Sync Queue 里面, 并且没有获取 lock 的 node 的前继节点不可能是 null)</span></span><br><span class="line">            <span class="keyword">if</span>(p == head)&#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);          <span class="comment">// 3. 判断前继节点是否是head节点(前继节点是head, 存在两种情况 (1) 前继节点现在占用 lock (2)前继节点是个空节点, 已经释放 lock, node 现在有机会获取 lock); 则再次调用 tryAcquireShared 尝试获取一下</span></span><br><span class="line">                <span class="keyword">if</span>(r &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);       <span class="comment">// 4. 获取 lock 成功, 设置新的 head, 并唤醒后继获取  readLock 的节点</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime(); <span class="comment">// 5. 计算还剩余的 timeout , 若小于0 则直接return</span></span><br><span class="line">            <span class="keyword">if</span>(nanosTimeout &lt;= <span class="number">0L</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp;         <span class="comment">// 6. 调用 shouldParkAfterFailedAcquire 判断是否需要中断(这里可能会一开始 返回 false, 但在此进去后直接返回 true(主要和前继节点的状态是否是 signal))</span></span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)&#123;<span class="comment">// 7. 在timeout 小于  spinForTimeoutThreshold 时 spin 的效率, 比 LockSupport 更高</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Thread.interrupted())&#123;                           <span class="comment">// 7. 若此次唤醒是 通过线程中断, 则直接抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)&#123;                <span class="comment">// 8. 在整个获取中出错(比如线程中断/超时)</span></span><br><span class="line">            cancelAcquire(node);    <span class="comment">// 10. 清除 node 节点(清除的过程是先给 node 打上 CANCELLED标志, 然后再删除)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractQueuedSynchronizer 释放共享lock 方法</strong></p>
<p>特点: 当 Sync Queue中存在连续多个获取 共享lock的节点时, 会出现并发的唤醒后继节点(因为共享模式下获取lock后会唤醒近邻的后继节点来获取lock)</p>
<p>流程:</p>
<ol>
<li>调用子类的 tryReleaseShared来进行释放 lock</li>
<li>判断是否需要唤醒后继节点来获取 lock</li>
</ol>
<p>调用流分类</p>
<p>场景1: Sync Queue 里面存在 : 1(共享) -&gt; 2(共享) -&gt; 3(共享) -&gt; 4(共享)<br>   节点1获取 lock 后调用 setHeadAndPropagate -&gt; doReleaseShared 唤醒 节点2 —&gt; 接下来 node 1 在 release 时再次 doReleaseShared, 而 node 2在获取 lock 后调用 setHeadAndPropagate 时再次 doReleaseShared -&gt; 直至到 node 4, node 4的状态变成 PROPAGATE (期间可能有些节点还没设置为 PROPAGATE 就被其他节点调用 setHead 而踢出 Sync Queue)</p>
<p>场景2: Sync Queue 里面存在 : 1(共享) -&gt; 2(共享) -&gt; 3(独占) -&gt; 4(共享)<br>   节点1获取 lock 后调用 setHeadAndPropagate -&gt; doReleaseShared 唤醒 节点2 —&gt; 接下来 node 1 在 release 时再次 doReleaseShared, 而 node 2 在获取 lock 后<br>   这是发现后继节点不是共享的, 则 Node 2 不在 setHeadAndPropagate 中调用 doReleaseShared, 而Node 3 没有获取lock, 将 Node 2 变成 SIGNAL, 而 node 2 在 release lock 时唤醒 node 3, 而 node 3 最终在 release lock 时 释放 node 4， node 4在release lock后状态还是保持 0</p>
<p>看代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases. This proceed in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of the head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        Node h = head;                      <span class="comment">// 1. 获取 head 节点, 准备 release</span></span><br><span class="line">        <span class="keyword">if</span>(h != <span class="keyword">null</span> &amp;&amp; h != tail)&#123;        <span class="comment">// 2. Sync Queue 里面不为 空</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span>(ws == Node.SIGNAL)&#123;         <span class="comment">// 3. h节点后面可能是 独占的节点, 也可能是 共享的, 并且请求了唤醒(就是给前继节点打标记 SIGNAL)</span></span><br><span class="line">                <span class="keyword">if</span>(!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))&#123; <span class="comment">// 4. h 恢复  waitStatus 值置0 (为啥这里要用 CAS 呢, 因为这里的调用可能是在 节点刚刚获取 lock, 而其他线程又对其进行中断, 所用cas就出现失败)</span></span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// loop to recheck cases</span></span><br><span class="line">                &#125;</span><br><span class="line">                unparkSuccessor(h);         <span class="comment">// 5. 唤醒后继节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))&#123; <span class="comment">//6. h后面没有节点需要唤醒, 则标识为 PROPAGATE 表示需要继续传递唤醒(主要是区别 独占节点最终状态0 (独占的节点在没有后继节点, 并且release lock 时最终 waitStatus 保存为 0))</span></span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// loop on failed CAS // 7. 同样这里可能存在竞争</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(h == head)&#123; <span class="comment">// 8. head 节点没变化, 直接 return(从这里也看出, 一个共享模式的 节点在其唤醒后继节点时, 只唤醒一个, 但是 它会在 获取 lock 时唤醒, 释放 lock 时也进行, 所以或导致竞争的操作)</span></span><br><span class="line">            <span class="keyword">break</span>;           <span class="comment">// head 变化了, 说明其他节点获取 lock 了, 自己的任务完成, 直接退出</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractQueuedSynchronizer 判断是否阻塞线程方法 shouldParkAfterFailedAcquire</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * shouldParkAfterFailedAcquire 这个方法最终的作用:</span></span><br><span class="line"><span class="comment"> *  本节点在进行 sleep 前一定需要给 前继节点打上 SIGNAL 标识(</span></span><br><span class="line"><span class="comment"> *  因为前继节点在 release lock 时会根据 这个标识决定是否需要唤醒后继节点来获取 lock,</span></span><br><span class="line"><span class="comment"> *  若释放时 标识是0, 则说明 Sync queue 里面没有等待获取lock的线程, 或Sync queue里面的节点正在获取 lock)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  一般流程:</span></span><br><span class="line"><span class="comment"> *      1. 第一次进入此方法 前继节点状态是 0, 则 CAS 为SIGNAL 返回 false(干嘛返回的是FALSE &lt;- 主要是为了再次 tryAcquire 一下, 说不定就能获取锁呢)</span></span><br><span class="line"><span class="comment"> *      2. 第二次进来 前继节点标志为SIGNAL, ok, 标识好了, 这下就可以安心睡觉, 不怕前继节点在释放lock后不进行唤醒我了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span>(ws == Node.SIGNAL)&#123;                                      <span class="comment">// 1. 判断是否已经给前继节点打上标识SIGNAL, 为前继节点释放 lock 时唤醒自己做准备</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ws &gt; <span class="number">0</span>)&#123;                                                 <span class="comment">// 2. 遇到个 CANCELLED 的节点 (ws &gt; 0 只可能是 CANCELLED 的节点, 也就是 获取中被中断, 或超时的节点)</span></span><br><span class="line">        <span class="comment">/**                                                     // 这里我们帮助删除</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            node.prev = pred = pred.prev;                    <span class="comment">// 3. 跳过所有 CANCELLED 的节点</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;                                    <span class="comment">// 跳过 CANCELLED 节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE. Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet. Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);     <span class="comment">// 4. 到这里 ws 只可能是 0 或 PROPAGATE (用于 共享模式的, 所以在共享模式中的提醒前继节点唤醒自己的方式,</span></span><br><span class="line">                                                            <span class="comment">// 也是给前继节点打上 SIGNAL标识 见 方法 "doReleaseShared" -&gt; "!compareAndSetWaitStatus(h, Node.SIGNAL, 0)" -&gt; unparkSuccessor)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractQueuedSynchronizer 线程自己中断方法selfInterrupt</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自我中断, 这主要是怕外面的线程不知道整个获取的过程中是否中断过, 所以才 ....</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractQueuedSynchronizer 中断线程方法parkAndCheckInterrupt</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中断当前线程, 并且返回此次的唤醒是否是通过中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    logger.info(Thread.currentThread().getName() + <span class="string">" "</span> + <span class="string">"parkAndCheckInterrupt , ThreadName:"</span> + Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted(); <span class="comment">//  Thread.interrupted() 会清除中断标识, 并返上次的中断标识</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AbstractQueuedSynchronizer-一般方法-队列检查方法"><a href="#AbstractQueuedSynchronizer-一般方法-队列检查方法" class="headerlink" title="AbstractQueuedSynchronizer 一般方法/队列检查方法"></a><strong>AbstractQueuedSynchronizer 一般方法/队列检查方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************* Queue inspection methods ****************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  SyncQueue 里面是否有 node 节点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> head != tail;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取 lock 是否发生竞争</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasContented</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> head != <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Sync Queue 里面的有效的, 最前面的 node 节点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Thread <span class="title">getFirstQueuedThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (head == tail) ? <span class="keyword">null</span> : fullGetFirstQueuedThread();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Sync Queue 里面的有效的, 最前面的 node 节点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> Thread <span class="title">fullGetFirstQueuedThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * The first node is normally head next. Try to get its</span></span><br><span class="line"><span class="comment">      * thread field, ensuring consistent reads: If thread</span></span><br><span class="line"><span class="comment">      * field is nulled out or s.prev is no longer head, then</span></span><br><span class="line"><span class="comment">      * some other thread(s) concurrently performed sethead in</span></span><br><span class="line"><span class="comment">      * between some of our reads. we try this twice before</span></span><br><span class="line"><span class="comment">      * restorting to traversal</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">     Node h, s;</span><br><span class="line">     Thread st;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 这里两次检测是怕线程 timeout 或 cancelled</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">if</span>((</span><br><span class="line">             (h = head) != <span class="keyword">null</span> &amp;&amp; (s = h.next) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     s.prev == head &amp;&amp; (st = s.thread) != <span class="keyword">null</span> ||</span><br><span class="line">                     (</span><br><span class="line">                             (h = head) != <span class="keyword">null</span> &amp;&amp; (s = h.next) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                     s.prev == head &amp;&amp; (st = s.thread) != <span class="keyword">null</span></span><br><span class="line">                             )</span><br><span class="line">             ))&#123;</span><br><span class="line">         <span class="keyword">return</span> st;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Head's next field might not have been set yet, or may have</span></span><br><span class="line"><span class="comment">      * been unset after setHead, So we must check to see if tail</span></span><br><span class="line"><span class="comment">      * is actually first node. If not, we continue on, safely</span></span><br><span class="line"><span class="comment">      * traversing from tail back to head to find first,</span></span><br><span class="line"><span class="comment">      * guaranteeing termination</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 从 tail 开始找</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     Node t = tail;</span><br><span class="line">     Thread firstThread = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">while</span>(t != <span class="keyword">null</span> &amp;&amp; t != head)&#123;</span><br><span class="line">         Thread tt = t.thread;</span><br><span class="line">         <span class="keyword">if</span>(tt != <span class="keyword">null</span>)&#123;</span><br><span class="line">             firstThread = tt;</span><br><span class="line">         &#125;</span><br><span class="line">         t = t.prev;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> firstThread;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 判断线程是否在 Sync Queue 里面</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isQueued</span><span class="params">(Thread thread)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(thread == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(Node p = tail; p != <span class="keyword">null</span>; p = p.prev)&#123; <span class="comment">// 从tail 开始</span></span><br><span class="line">         <span class="keyword">if</span>(p.thread == thread)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 判断 Sync Queue 中等待获取 lock 的第一个 node 是否是 获取 writeLock 的(head 节点是已经获取 lock 的节点)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Node h, s;</span><br><span class="line">     <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">             (s = h.next) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">             !s.isShared()       &amp;&amp;</span><br><span class="line">             s.thread != <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 当前节点之前在 Sync Queue 里面是否有等待获取的 Node</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * The correctness of this depends on head being initialized</span></span><br><span class="line"><span class="comment">      * before tail and on head next being accurate if the current</span></span><br><span class="line"><span class="comment">      * thread is first in queue</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">     Node h = head;</span><br><span class="line">     Node s;</span><br><span class="line">     <span class="keyword">return</span> h != t &amp;&amp;        <span class="comment">// h != t 表示 Sync Queu 里面至少存在 一个节点 (这时的 h节点可能是 null)</span></span><br><span class="line">             ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread()); <span class="comment">// (s = h.next) == null 说明 h节点获取 lock, 而后又被其他获取 lock 的节点从 Sync Queue 里面剔除掉了</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/********************************************* Instrumentation and monitoring methods **************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取 Sync Queue 里面 等待 获取 lock 的 长度</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(Node p = tail; p != <span class="keyword">null</span>; p = p.prev)&#123;</span><br><span class="line">         <span class="keyword">if</span>(p.thread != <span class="keyword">null</span>)&#123;</span><br><span class="line">             ++n;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> n;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取 Sync Queue 里面 等待 获取 lock 的 thread</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span></span>&#123;</span><br><span class="line">     ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span>(Node p = tail; p != <span class="keyword">null</span>; p = p.prev)&#123;</span><br><span class="line">         Thread t = p.thread;</span><br><span class="line">         <span class="keyword">if</span>(t != <span class="keyword">null</span>)&#123;</span><br><span class="line">             list.add(t);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> list;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取 Sync Queue 里面 等待 获取 writeLock 的 thread</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title">getExclusiveQueuedThreads</span><span class="params">()</span></span>&#123;</span><br><span class="line">     ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span>(Node p = tail; p != <span class="keyword">null</span>; p = p.prev)&#123;</span><br><span class="line">         <span class="keyword">if</span>(!p.isShared())&#123;</span><br><span class="line">             Thread t = p.thread;</span><br><span class="line">             <span class="keyword">if</span>(t != <span class="keyword">null</span>)&#123;</span><br><span class="line">                 list.add(t);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> list;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取 Sync Queue 里面 等待 获取 readLock 的 thread</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title">getSharedQueuedThreads</span><span class="params">()</span></span>&#123;</span><br><span class="line">     ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span>(Node p = tail; p != <span class="keyword">null</span>; p = p.prev)&#123;</span><br><span class="line">         <span class="keyword">if</span>(p.isShared())&#123;</span><br><span class="line">             Thread t = p.thread;</span><br><span class="line">             <span class="keyword">if</span>(t != <span class="keyword">null</span>)&#123;</span><br><span class="line">                 list.add(t);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> list;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> s = getState();</span><br><span class="line">     String q = hasQueuedThreads() ? <span class="string">"non"</span> : <span class="string">""</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">"[State = "</span> + s + <span class="string">", "</span> + q + <span class="string">" empty queue]"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*********************** Internal support methods for Conditions ***********************/</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 判断 node 是否在 Sync Queue 里面</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 这里有点 tricky,</span></span><br><span class="line"><span class="comment">      * node.waitStatus == Node.CONDITION 则说明 node 一定在 Condition 里面</span></span><br><span class="line"><span class="comment">      * node.prev == null 说明 node 一定不在 Sync Queue 里面</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">if</span>(node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// node.next != null 则 node 一定在 Sync Queue; 但是反过来 在Sync Queue 里面的节点 不一定  node.next != null</span></span><br><span class="line">     <span class="keyword">if</span>(node.next != <span class="keyword">null</span>)&#123; <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * node.prev can be non-null, but not yet on queue because</span></span><br><span class="line"><span class="comment">      * the CAS to place it on queue can fail. So we have to</span></span><br><span class="line"><span class="comment">      * traverse from tail to make sure it actually make it. It</span></span><br><span class="line"><span class="comment">      * will always be near the tail in calls to this method, and</span></span><br><span class="line"><span class="comment">      * unless the CAS failed (which is unlikely), it will be</span></span><br><span class="line"><span class="comment">      * there, so we hardly ever traverse much</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 因为这里存在 node 开始enq Sync Queue 的情形, 所以在此查找一下</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 从 tail 开始查找 node</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">     Node t = tail;</span><br><span class="line">     <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">         <span class="keyword">if</span>(t == node)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(t == <span class="keyword">null</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         t = t.prev;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将 Node 从Condition Queue 转移到 Sync Queue 里面</span></span><br><span class="line"><span class="comment">  * 在调用transferForSignal之前, 会 first.nextWaiter = null;</span></span><br><span class="line"><span class="comment">  * 而我们发现 若节点是因为 timeout / interrupt 进行转移, 则不会清除两种情况的转移都会把 wautStatus 置为 0</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * If cannot change waitStatus, the node has been cancelled</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">if</span>(!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))&#123; <span class="comment">// 1. 若 node 已经 cancelled 则失败</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">      * indicate that thread is (probably) waiting, If cancelled or</span></span><br><span class="line"><span class="comment">      * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">      * case the waitStatus can be transiently and harmlessly wrong)</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     Node p = enq(node);                                 <span class="comment">// 2. 加入 Sync Queue</span></span><br><span class="line">     <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">     <span class="keyword">if</span>(ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))&#123; <span class="comment">// 3. 这里的 ws &gt; 0 指Sync Queue 中node 的前继节点cancelled 了, 所以, 唤醒一下 node ; compareAndSetWaitStatus(p, ws, Node.SIGNAL)失败, 则说明 前继节点已经变成 SIGNAL 或 cancelled, 所以也要 唤醒</span></span><br><span class="line">         LockSupport.unpark(node.thread);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将 Condition Queue 中因 timeout/interrupt 而唤醒的节点进行转移</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))&#123; <span class="comment">// 1. 没有 node 没有 cancelled , 直接进行转移 (转移后, Sync Queue , Condition Queue 都会存在 node)</span></span><br><span class="line">         enq(node);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * If we lost out to a signal(), then we can't proceed</span></span><br><span class="line"><span class="comment">      * until it finishes its enq(). Cancelling during an</span></span><br><span class="line"><span class="comment">      * incomplete transfer is both race and transient, so just</span></span><br><span class="line"><span class="comment">      * spin</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">while</span>(!isOnSyncQueue(node))&#123;                <span class="comment">// 2.这时是其他的线程发送signal,将本线程转移到 Sync Queue 里面的工程中(转移的过程中 waitStatus = 0了, 所以上面的 CAS 操作失败)</span></span><br><span class="line">         Thread.yield();                         <span class="comment">// 这里调用 isOnSyncQueue判断是否已经 入Sync Queue 了</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/******************** Instrumentation methods for conditions ***************/</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * condition 是否属于这个 AQS 的</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">owns</span><span class="params">(ConditionObject condition)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> condition.isOwnedBy(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 这个 condition Queue 里面是否有等待的线程</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasWaiters</span><span class="params">(ConditionObject condition)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(!owns(condition))&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> condition.hasWaiters();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 这个 condition Queue 里面等待的线程的量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWaitQueueLength</span><span class="params">(ConditionObject condition)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(!owns(condition))&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Not owner"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> condition.getWaitQueueLength();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 这个 condition Queue 里面等待的线程</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title">getWaitingThreads</span><span class="params">(ConditionObject condition)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(!owns(condition))&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"not owner"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> condition.getWaitingThreads();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速总结"><a href="#快速总结" class="headerlink" title="快速总结"></a>快速总结</h3><ol>
<li>两个状态<ol>
<li>waitStatus<ol>
<li>0 刚创建状态</li>
<li>1 取消状态</li>
<li>-1 唤醒后续结点</li>
<li>-2 condition 状态</li>
<li>-3 propagete 状态</li>
</ol>
</li>
<li>nextWaiter<ol>
<li>如果在 condition queue，指向下一个结点</li>
<li>如果在 sync queue，标识共享结点还是独占结点</li>
</ol>
</li>
</ol>
</li>
<li>CLH锁的变种。CLH 是一种基于逻辑队列的非线程饥饿的自旋公平锁。通过在本地线程自旋获取锁的方式，避免线程饥饿。<ol>
<li>包含<ol>
<li>AtomicReference<clhnode> tailNode。防止 ABA 问题的原子类</clhnode></li>
<li>ThreadLocal<clhnode> predNode 前一个结点引用</clhnode></li>
<li>ThreadLocal<clhnode> curNode</clhnode></li>
</ol>
</li>
<li>逻辑<ol>
<li>加锁<ol>
<li>设置当前结点为 true，表示获取到了锁或等待加锁</li>
<li>将当前结点 CAS 设置为尾结点，并返回上一个结点</li>
<li>将上个结点放到本地线程中</li>
<li>在本地线程对上一个结点的状态进行 CAS 获取锁</li>
</ol>
</li>
<li>释放锁<ol>
<li>设置当前结点为 false，表示释放锁</li>
<li>重新 new 一个新结点，替换当前结点，防止死 CAS</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>addWaiter 先试一下，在 enq</li>
<li>enq 自旋，直到进入为止</li>
<li>unparkSuccessor 唤醒后续(LockSupport.unpark)。顺便清除 cancel 的结点</li>
<li>doReleaseShared <ol>
<li>当前结点设为 0 ，调用 unparkSuccessor</li>
<li>如果本身就是 0，设为 propagete</li>
</ol>
</li>
<li>setHeadAndPropagate 当tryAcquireShared拿到资源，并且后续结点为 shared 模式，调用 doReleaseShared</li>
<li>cancelAcquire <ol>
<li>首先清理前面所有 cancel 的结点</li>
<li>当前结点设置为 cancel</li>
<li>如果本身就是尾结点，直接去掉就行</li>
<li>否则把前后的结点拼接起来</li>
</ol>
</li>
<li>shouldParkAfterFailedAcquire <ol>
<li>如果 prev 已经是signal 返回 true</li>
<li>如果 prev 是 cancel 的，就清理一遍 cancle 结点</li>
<li>设置 prev 为 signal，返回 false</li>
<li>返回上层，在试一次有没有机会获取资源</li>
</ol>
</li>
<li>selfInterrupt  {Thread.currentThread().interrupt();}</li>
<li>parkAndCheckInterrupt <ol>
<li>LockSupport.park(this)挂起线程</li>
<li>return Thread.interrupted(); 返回 park 是否被中断过，并清空中断位。</li>
</ol>
</li>
<li><ol>
<li>acquireQueued 占用资源。独占模式<ol>
<li>尝试是否能获取资源</li>
<li>否则 shouldParkAfterFailedAcquire &amp;&amp; parkAndCheckInterrupt</li>
<li>CAS 以上两步</li>
</ol>
</li>
<li>doAcquireInterruptibly 被中断抛出异常</li>
<li>doAcquireNanos 中断抛出异常</li>
<li>doAcquireShared 共享模式<ol>
<li>tryAcquireShared</li>
<li>如果获取资源，调用 setHeadAndPropagate</li>
<li>否则shouldParkAfterFailedAcquire &amp;&amp; parkAndCheckInterrupt</li>
<li>CAS 以上</li>
</ol>
</li>
<li>doAcquireSharedInterruptibly 中断抛出异常</li>
<li>doAcquireSharedNanos 中断抛出异常</li>
</ol>
</li>
<li>tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared、isHeldExclusively 由子类实现</li>
<li><ol>
<li>acquire : tryAcquire &amp;&amp; acquireQueued 独占模式</li>
<li>acquireInterruptibly 中断抛出异常</li>
<li>tryAcquireNanos 中断抛出异常</li>
</ol>
</li>
<li>release ： tryRelease，成功后unparkSuccessor</li>
<li><ol>
<li>acquireShared tryAcquireShared &amp;&amp; doAcquireShared 共享模式</li>
<li>acquireSharedInterruptibly 中断抛出异常</li>
</ol>
</li>
<li>releaseShared</li>
<li>transferForSignal 把结点从 condition 移动到sync 队列<ol>
<li>结点从 condition 状态变为 0</li>
<li>enq 入队</li>
<li>如果前一个结点无效，或前一个节点设置 signal 失败，则 unpark 当前线程</li>
</ol>
</li>
<li>transferAfterCancelledWait 把 condition 中放弃等待的结点(设置为 0)移入 sync 队列(enq)</li>
<li>ConditionObject<ol>
<li>addConditionWaiter 添加一个结点到 condition 队列<ol>
<li>unlinkCancelledWaiters 清理不是 condition 状态的结点</li>
<li>新建一个 condition 结点追加进去</li>
</ol>
</li>
</ol>
</li>
<li>await<ol>
<li>如果线程已经被中断，则抛出异常</li>
<li>添加一个结点到 condition</li>
<li>释放当前结点所占用的资源，并唤醒后续结点</li>
<li>park 当前线程，直到被移动到 sync 队列</li>
<li>检查park 是否被中断，如果被中断，调用 transferAfterCancelledWait ，转移到 sync 队列</li>
<li>调用 acquireQueued ，看似是去获取资源，但是传入的 saveState 由于已经被释放掉了为 0，所以这一步的操作，其实是利用 shouldParkAfterFailedAcquire 清理掉状态为 cancel 的结点</li>
<li>报告中断情况</li>
</ol>
</li>
<li>doSignal 调用 transferForSignal</li>
</ol>
<blockquote>
<p>参考：<br><a href="https://www.jianshu.com/p/e7659436538b" target="_blank" rel="noopener">AbstractQueuedSynchronizer 源码分析 (基于Java 8)</a><br><a href="https://www.cnblogs.com/waterystone/p/4920797.html#!comments" target="_blank" rel="noopener">Java并发之AQS详解</a><br><a href="https://www.jianshu.com/p/4682a6b0802d" target="_blank" rel="noopener">并发编程——详解 AQS CLH 锁</a></p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/J-U-C/" rel="tag"># J.U.C</a>
          
            <a href="/tags/源码/" rel="tag"># 源码</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/09/07/concurrent/CLH队列锁/" rel="next" title="CLH队列锁">
                <i class="fa fa-chevron-left"></i> CLH队列锁
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/09/09/algorithm/算法笔记/" rel="prev" title="算法笔记">
                算法笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">R.D</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
<br>

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#简述"><span class="nav-number">1.</span> <span class="nav-text">简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码分析"><span class="nav-number">2.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AbstractQueuedSynchronizer-内部类-Node"><span class="nav-number">2.1.</span> <span class="nav-text">AbstractQueuedSynchronizer 内部类 Node</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AbstractQueuedSynchronizer-内部Queue-：Condition-Queue"><span class="nav-number">2.2.</span> <span class="nav-text">AbstractQueuedSynchronizer 内部Queue ：Condition Queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AbstractQueuedSynchronizer-内部-Queue-Sync-Queue"><span class="nav-number">2.3.</span> <span class="nav-text">AbstractQueuedSynchronizer 内部 Queue Sync Queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AbstractQueuedSynchronizer-一般方法-队列检查方法"><span class="nav-number">2.4.</span> <span class="nav-text">AbstractQueuedSynchronizer 一般方法/队列检查方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速总结"><span class="nav-number">3.</span> <span class="nav-text">快速总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">R.D</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
