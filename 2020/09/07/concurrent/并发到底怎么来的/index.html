<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="J.U.C,">










<meta name="description" content="到底什么是并发，并发又是怎么来的呢？">
<meta name="keywords" content="J.U.C">
<meta property="og:type" content="article">
<meta property="og:title" content="并发到底怎么来的">
<meta property="og:url" content="http://blog.intersico.com/2020/09/07/concurrent/并发到底怎么来的/index.html">
<meta property="og:site_name" content="Every Day">
<meta property="og:description" content="到底什么是并发，并发又是怎么来的呢？">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://blog.intersico.com/2020/09/07/concurrent/并发到底怎么来的/head.jpg">
<meta property="og:image" content="http://blog.intersico.com/2020/09/07/concurrent/并发到底怎么来的/cpu.jpg">
<meta property="og:image" content="http://blog.intersico.com/2020/09/07/concurrent/并发到底怎么来的/MESI.jpg">
<meta property="og:image" content="http://blog.intersico.com/2020/09/07/concurrent/并发到底怎么来的/cpu.jpg">
<meta property="og:image" content="http://blog.intersico.com/2020/09/07/concurrent/并发到底怎么来的/barriers.jpg">
<meta property="og:image" content="http://blog.intersico.com/2020/09/07/concurrent/并发到底怎么来的/monitor.jpg">
<meta property="og:image" content="http://blog.intersico.com/2020/09/07/concurrent/并发到底怎么来的/MESA.jpg">
<meta property="og:image" content="http://blog.intersico.com/2020/09/07/concurrent/并发到底怎么来的/data_area.jpg">
<meta property="og:image" content="http://blog.intersico.com/2020/09/07/concurrent/并发到底怎么来的/markword_1.jpg">
<meta property="og:image" content="http://blog.intersico.com/2020/09/07/concurrent/并发到底怎么来的/markword_2.jpg">
<meta property="og:image" content="http://blog.intersico.com/2020/09/07/concurrent/并发到底怎么来的/synchronized.jpg">
<meta property="og:updated_time" content="2020-09-07T10:55:48.954Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="并发到底怎么来的">
<meta name="twitter:description" content="到底什么是并发，并发又是怎么来的呢？">
<meta name="twitter:image" content="http://blog.intersico.com/2020/09/07/concurrent/并发到底怎么来的/head.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.intersico.com/2020/09/07/concurrent/并发到底怎么来的/">





  <title>并发到底怎么来的 | Every Day</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Every Day</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.intersico.com/2020/09/07/concurrent/并发到底怎么来的/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="R.D">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Every Day">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">并发到底怎么来的</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-07T10:50:12+08:00">
                2020-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/并发/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <img src="/2020/09/07/concurrent/并发到底怎么来的/head.jpg">

<p>到底什么是并发，并发又是怎么来的呢？</p>
<a id="more"></a>

<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>首先并发不是 Java 特有的概念，任何一种多线程的语言都会涉及并发问题，只是根据不同线程模型有不同的解决方案(Java 的线程模型是映射到底层操作系统的线程模型上)。Java 从一开始就支持多线程，所以肯定包含各种解决方案，从 JVM 层面的 volatile、synchronized 等关键词，到 java 内存模型，再到 JUC 包中各种解决不同场景的并发包工具类库等。</p>
<p>所有这些方案，我感觉都在解决两个宏观方面的问题：多线程合作与多线程竞争。<br>多线程合作，比如生产者-消费者模式、Worker Thread、Fork/Join、同步异步模型等，多个线程互相配合互相协作来提高程序性能。而多线程合作必然带来竞争问题，也就是共享资源的竞争问题：可见性、有序性、原子性。</p>
<p>可见性、有序性、原子性，是多核时代并发编程绕不开的问题，这篇文章就想聊一下这三个问题是如何产生的，毕竟知道了问题是如何产生的，才能更好的知道 java 或其他语言是如何解决的。首先明确一点，可见性、有序性、原子性是硬件层面与软件层面都存在的问题，所以想要解决这三个问题，需要从硬件层到软件层都有了解，互相配合才能解决并发问题。</p>
<h2 id="系统级优化带来的问题"><a href="#系统级优化带来的问题" class="headerlink" title="系统级优化带来的问题"></a>系统级优化带来的问题</h2><p>大家都知道，cpu 的运算速度远远大于内存，而内存又远远大于 IO，根据木桶理论，一个系统的性能取决于最短的木板。大部分程序都既有计算又有 IO 操作，为了提高 cpu 和 IO 的利用率，硬件结构、操作系统、编译程序做出了以下优化：</p>
<ul>
<li>CPU 增加了多级缓存，以均衡与内存的速度差异</li>
<li>操作系统分时复用 CPU，均衡与 IO 的速度差异</li>
<li>编译程序优化指令执行顺序，更加合理的利用缓存</li>
</ul>
<p>而正是这三个系统级别的优化，给我们这个多核时代带来了可见性、有序性、原子性问题。如果是在单核时代，那就没那么多问题了，而且这个优化对于程序的性能提升很大。为什么多核会有问题呢？</p>
<h3 id="CPU-结构"><a href="#CPU-结构" class="headerlink" title="CPU 结构"></a>CPU 结构</h3><p>一个最简单的 CPU 结构如下：</p>
<img src="/2020/09/07/concurrent/并发到底怎么来的/cpu.jpg">

<p>真实的 CPU 会有多级缓存L1、L1d、L1i、共享缓存等，而且不同厂商的 CPU 还会有各种其他的缓存。图中 CPU0 和 CPU1 各有一个缓存，最下面的 Memory 是主存。 CPU0 和 CPU1 都从主存拿一条数据，一开始大家都是读，相安无事。然后 CPU0 修改了这个数据，但是在没有写回主存前，对 CPU1 是不可见的，而 CPU1 呢还在傻傻的使用，这就是可见性问题。</p>
<h2 id="可见性问题的诞生"><a href="#可见性问题的诞生" class="headerlink" title="可见性问题的诞生"></a>可见性问题的诞生</h2><p>可见性存在于两个层面，一个是硬件层面(也叫缓存一致性问题)，一个存在于软件层面(也叫内存一致性问题)，我们先说硬件层面。</p>
<h3 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h3><p>CPU 为了平衡与主存的速度问题，给每个内核加入了多级缓存，而每个内核缓存彼此不可见，这就是缓存一致性问题。既然是硬件的问题，那硬件方面肯定会有解决方案，比较经典的就是MESI 协议。</p>
<h4 id="MESI-协议"><a href="#MESI-协议" class="headerlink" title="MESI 协议"></a>MESI 协议</h4><p>MESI描述了共享的状态。</p>
<p>在CPU 的 cache 中，是以 cache line 作为缓存的基本单位，什么是 cache line 呢？这其实也是一种优化手段，CPU 从主存读写数据是比较耗时的，所以当从主存读一个数据时，会认为这个数据相邻的数据也被读取的概率很大，所以会把其相邻内存块的数据一起读到缓存中，这就形成了 cache line 的概念(伪共享的概念也是从这来的)。</p>
<p>在MESI中，每个 cache line 定义了4 个状态，分别是：</p>
<ul>
<li><strong>M(Modified)：</strong> 这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在与本 Cache 中。</li>
<li><strong>E(Exclusive)：</strong> 这行数据有效，数据和内存中的数据一致，数据只存在于本 Cache 中。</li>
<li><strong>S(Shared)：</strong> 这行数据有效，数据和内存中的数据一致，数据存在与很多 Cache 中。</li>
<li><strong>I(Invalid)：</strong> 这行数据无效</li>
</ul>
<p>Exclusive  和 Shared 都是有效且和主存中一样的数据，区别就是前者只是本核的缓存有，而其他人没有。后者则是不止我有，很多其他人也有。</p>
<p>Modified：当某核更改了自己缓存中的这条数据时，会通知其他也有这条数据的人，让他们把这条数据标记为 Invalid，也就是脏数据。</p>
<p>多核的缓存，通过这个四个状态流转，从而保证缓存一致性。每个 Cache 的 Cache控制器不仅知道自己的读写操作，也会监听(snoop)其他 cache 的读写操作。当内核需要访问的数据不在本 cache 中，而其他 cache 有这份数据的备份时，本 cache 可以选择从主存导入数据，也可以从其他 cache 中导入数据，不同的处理器会有不同的实现。MESI 并没有定义这些细节，只是定义了状态之间的转移。其流转状态如下(假设本cache从主存导入数据)：</p>
<img src="/2020/09/07/concurrent/并发到底怎么来的/MESI.jpg">

<p><strong>Local Read:</strong> 本内核读本 cache 中的值<br><strong>Local Write:</strong> 本内核写本 cache 中的值<br><strong>Remote Read:</strong> 其他内核读其cache 中的值<br><strong>Remote Write:</strong> 其他内核写其cache 中的值</p>
<p>上面所述，就是硬件层面的缓存一致性问题。那软件层面的呢？</p>
<h3 id="内存一致性问题"><a href="#内存一致性问题" class="headerlink" title="内存一致性问题"></a>内存一致性问题</h3><p>JVM 为了提高程序性能，定义了工作内存这个概念，类似于 CPU 的缓存，对主存的数据读写之上，加了一层工作内存，每个线程都有自己的工作内存且互相不可见，这就是软件层面的可见性问题，也叫内存一致性问题。</p>
<h4 id="volatile-如何保证内存一致性"><a href="#volatile-如何保证内存一致性" class="headerlink" title="volatile 如何保证内存一致性"></a>volatile 如何保证内存一致性</h4><p>Java通过几种原子操作完成工作内存和主存的交互，从而保证一致性：</p>
<ul>
<li>lock：作用于主内存，把变量标识为线程独占状态。</li>
<li>unlock：作用于主内存，解除独占状态。</li>
<li>read：作用主内存，把一个变量的值从主内存传输到线程的工作内存。</li>
<li>load：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中。</li>
<li>use：作用工作内存，把工作内存当中的一个变量值传给执行引擎。</li>
<li>assign：作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。</li>
<li>store：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。</li>
<li>write：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中。</li>
</ul>
<p>Volatile的特殊规则就是：</p>
<ol>
<li>read、load、use动作必须连续出现</li>
<li>assign、store、write动作必须连续出现</li>
</ol>
<p>所以使用Volatile可以保证：</p>
<ol>
<li>每次读取前必须先从主内存刷新最新的值</li>
<li>每次写入后必须立即同步回主内存当中</li>
</ol>
<p>也就是说，Volatile 关键词修饰的变量看到的随时是最新的值。</p>
<p>以上，我们从硬件层面和软件层面解释了可见性问题的由来，其根本原因就是为了优化性能而带来的一些问题，而其中还有一个比较复杂的问题，就是排序性问题。</p>
<h2 id="排序性问题的诞生"><a href="#排序性问题的诞生" class="headerlink" title="排序性问题的诞生"></a>排序性问题的诞生</h2><p>首先提出一点就是，排序问题会产生可见性问题。排序性问题无时无刻不在发生，包含两种场景：CPU执行指令时乱序优化(硬件层面)和编译器编译时优化(软件层面)。</p>
<h3 id="CPU指令乱序"><a href="#CPU指令乱序" class="headerlink" title="CPU指令乱序"></a>CPU指令乱序</h3><p>处理器层面的乱序优化节省了大量等待时间，提高了处理器的性能。其实所谓乱序，也是要按照一定规则进行的：只要两个指令之间不存在数据依赖，就可以对这两个指令乱序。说白了，就是只要不影响程序在单线程顺序执行的结果，就可以对两个指令重排序。</p>
<p>在不重排的情况下，处理器指令执行如下：</p>
<ol>
<li>指令获取</li>
<li>如果输入的运算对象是可以获取的(比如已经存在于寄存器中)，这条指令会被发送到合适的功能单元。如果运算对象在当前的时钟周期中是不可获取的(通常需要从主存获取)，处理器会开始等待直到他们是可以获取的</li>
<li>指令在合适的功能单元中被执行</li>
<li>功能单元将运算结果写回寄存器</li>
</ol>
<p>乱序优化后的执行过程如下：</p>
<ol>
<li>指令获取</li>
<li>指令被发送到一个指令序列(也称执行缓冲区或保留站)中</li>
<li>指令将在序列中等待，直到它的数据运算对象是可以获取的，然后指令被允许在先进入的、旧的指令之前离开序列缓冲区。(此处表现为乱序)</li>
<li>指令被分配给一个合适的功能单元执行</li>
<li>结果被放到一个序列中</li>
<li>仅当所有在该指令之前的指令都将他们的结果写入寄存器后，这条指令的结果才会被写入寄存器。(重整乱序结果)</li>
</ol>
<p>对于指令乱序在单核时代不影响正确性，但是对于多核且多个线程能跑在不同核上并行运行时，一旦出现共享数据，就会出问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutofOrderExecution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                a = <span class="number">1</span>;</span><br><span class="line">                x = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                b = <span class="number">1</span>;</span><br><span class="line">                y = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">"("</span> + x + <span class="string">","</span> + y + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不考虑重排序和带来的可见性问题，上面代码会输出什么呢？当两个线程交替运行，可能会得到(0,1),(1,0),(1,1)。但还有可能是(0,0)，因为t1 线程中，a=1 和 x=b 不存在依赖关系，因此两行代码可以重排序，t2 也是如此。</p>
<p>以上的 bug 也可以说是可见性带来的问题，但重排序引发的问题远不止可见性那么简单，最经典的问题就是双重检查创建单例。</p>
<h4 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双重检查大家都知道加锁，防止产生多个单例对象，但是如果忽略重排序，可能会得到半个对象。问题就出在 new Singleton()。</p>
<p>正常的逻辑应该是：</p>
<ol>
<li>分配一块内存 M</li>
<li>在内存 M上初始化 Singleton 对象</li>
<li>M 的地址赋值给 instance 变量</li>
</ol>
<p>但实际上优化后可能是：</p>
<ol>
<li>分配一块内存 M</li>
<li>将M 的地址赋值给 instance 变量</li>
<li>最后在内存 M上初始化 Singleton 对象</li>
</ol>
<p>所以正确做法是给 Singleton 变量加上 volatile 关键词，或使用内部类做懒汉单例模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SingletonHolder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以说依然是懒汉模式，因为 java 内部类是懒加载的，也就是用到了才会加载。之所以说是线程安全的，这是由 JVM 类加载机制保护的，类加载本身就是线程安全的。</p>
<p>那如何解决指令重排序的问题呢？引出下一个概念，内存屏障。</p>
<h4 id="内存屏障-Memory-Barrier-Fence"><a href="#内存屏障-Memory-Barrier-Fence" class="headerlink" title="内存屏障(Memory Barrier/Fence)"></a>内存屏障(Memory Barrier/Fence)</h4><p>内存屏障可以解决硬件层面的可见性与重排性问题。有人问，可见性不是上面由 MESI 协议解决了吗？其实还有一部分缓存是 MESI 没有解决的，可以回顾最开始 CPU 架构图，有个store buffer 和Invalidate Queue。</p>
<p>CPU 架构中传统的MESI 协议中有两个行为的执行成本比较大，一个是将某个cache line标记为 Invalid 状态，另一个是当某 cache line 当前状态为 Invalid 时写入新的数据。所以 CPU 通过 store buffer 和 Invalidate Queue 组件来降低这类操作的延迟。</p>
<img src="/2020/09/07/concurrent/并发到底怎么来的/cpu.jpg">

<p>当一个 core 在 Invalid 状态进行写入时，首先会给其它 core 发送 Invalid 消息，然后把当前写入的数据写入到 Store Buffer 中。然后异步在某个时刻真正的写入到 Cache Line中。当前 core 如果要读 Cache Line 中的数据，需要先扫描 Store Buffer 之后再读取Cache Line（Store-Buffer Forwarding）。但是此时其它 core 是看不到当前 core 的Store Buffer 中的数据的，要等到  Store Buffer中的数据被刷到了Cache Line 之后才会触发失效操作。</p>
<p>而当一个 core 收到 Invalid 消息时，会把消息写入自身的Invalidate Queue中，随后异步将其设为Invalid状态。和Store Buffer不同的是，当前core使用Cache时并不扫描Invalidate Queue部分，所以可能会有极短时间的脏读问题。</p>
<p>内存对于缓存更新策略，要区分Write-Through和Write-Back两种策略。前者更新内容直接写内存，但并不同时更新Cache，但要置Cache失效，后者先更新Cache，随后异步更新内存。通常X86 CPU更新内存都使用Write-Back策略。</p>
<p>两个指令：</p>
<ol>
<li><strong>store：</strong> 将处理器缓存的数据刷新到内存中</li>
<li><strong>load：</strong> 将内存存储的数据拷贝到处理器的缓存中</li>
</ol>
<img src="/2020/09/07/concurrent/并发到底怎么来的/barriers.jpg">

<p>StoreLoad Barriers同时具备其他三个屏障的效果，因此也称之为全能屏障（mfence），是目前大多数处理器所支持的；但是相对其他屏障，该屏障的开销相对昂贵。然而，除了mfence，不同的CPU架构对内存屏障的实现方式与实现程度非常不一样。</p>
<p>Intel为此提供三种内存屏障指令：</p>
<ol>
<li>sfence ，实现Store Barrior 会将store buffer中缓存的修改刷入L1 cache中，使得其他core可以观察到这些修改，而且之后的写操作不会被调度到之前，即sfence之前的写操作一定在sfence完成且全局可见；</li>
<li>lfence ，实现Load Barrior 会将invalidate queue失效，强制读取入L1 cache中，而且lfence之后的读操作不会被调度到之前，即lfence之前的读操作一定在lfence完成（并未规定全局可见性）；</li>
<li>mfence ，实现Full Barrior 同时刷新store buffer和invalidate queue，保证了mfence前后的读写操作的顺序，同时要求mfence之后写操作结果全局可见之前，mfence之前写操作结果全局可见；</li>
</ol>
<p>以上，即是硬件层面的重排序问题与解决方案，但是这个解决方案是否生效可能还需要volatile关键词的配合。</p>
<h3 id="编译器指令重排"><a href="#编译器指令重排" class="headerlink" title="编译器指令重排"></a>编译器指令重排</h3><h4 id="volatile如何解决指令重排问题"><a href="#volatile如何解决指令重排问题" class="headerlink" title="volatile如何解决指令重排问题"></a>volatile如何解决指令重排问题</h4><p>首先我们知道编译器层面也有指令重排优化，用volatile就可以很好的解决，volatile可以同时解决软件层面的可见性问题和排序性问题。那如何同时触发硬件层的内存屏障呢？</p>
<p>如果硬件架构本身不进行处理器重排序、有更强的重排序语义（能够分析多核间的数据依赖）、或在单核处理器上重排序，那么volatile就是一个空标记，不会插入相关语义的内存屏障。</p>
<p>如果不保证，仍以x86架构为例，JVM对volatile变量的处理如下：</p>
<ol>
<li>在写volatile变量v之后，插入一个sfence。这样，sfence之前的所有store（包括写v）不会被重排序到sfence之后，sfence之后的所有store不会被重排序到sfence之前，禁用跨sfence的store重排序；且sfence之前修改的值都会被写回缓存，并标记其他CPU中的缓存失效。</li>
<li>在读volatile变量v之前，插入一个lfence。这样，lfence之后的load（包括读v）不会被重排序到lfence之前，lfence之前的load不会被重排序到lfence之后，禁用跨lfence的load重排序；且lfence之后，会首先刷新无效缓存，从而得到最新的修改值，与sfence配合保证内存可见性。</li>
</ol>
<p>二者结合，共同实现了Happens-Before关系中的volatile变量规则。而内存一致性与软件层面的重排序问题也就引申处来了 JMM(java 内存模型)</p>
<h4 id="Happens-Before原则"><a href="#Happens-Before原则" class="headerlink" title="Happens-Before原则"></a>Happens-Before原则</h4><p>Happens-Before原则如何理解呢？其想表达的意思是：前面一个操作的结果对后续操作是可见的。Happens-Before约束了编译器优化行为，虽然允许编译器优化，但是要求其优化后一定遵守Happens-Before规则。</p>
<p>Happens-Before原则有针对程序开发人员的和虚拟机开发人员的，我们就只列出针对程序开发人员的 8 项原则。</p>
<ol>
<li>程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li>
<li>管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面”是指时间上的先后顺序。</li>
<li>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的”后面”同样是指时间上的先后顺序。</li>
<li>传递性：这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。</li>
<li>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</li>
<li>对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。</li>
</ol>
<p>以上我们就说完了系统优化后，带来的可见性与排序性问题。那么最后还有一个问题，就是原子性问题。</p>
<h2 id="原子性问题的诞生"><a href="#原子性问题的诞生" class="headerlink" title="原子性问题的诞生"></a>原子性问题的诞生</h2><p>而这个问题产生的原因就是 cpu 的分时复用。所谓的原子性是指指令级别的原子性，而不是高级语言语句级别，因为一条高级语言语句其底层可能对应好几条指令。</p>
<p>解决原子性问题就是加锁了，JVM 层面的锁synchronized，或 JUC 代码层面的 lock/unlock 等。锁的种类有很多，分别处理不同的场景，比如共享锁、排它锁、自旋锁、偏向锁等。这里要讨论的是synchronized锁的问题，毕竟JUC 工具中的锁大部分都是 CAS 的自旋锁或reentrantlock排它锁(底层模型和synchronized一样)。</p>
<h3 id="管程模型与synchronized优化"><a href="#管程模型与synchronized优化" class="headerlink" title="管程模型与synchronized优化"></a>管程模型与synchronized优化</h3><p>一说到synchronized我们都感觉是重量级锁，在 1.5 之前确实是，但是在 1.6 之后随着对synchronized优化，加入了偏向锁、适应性自旋锁、轻量级锁等，synchronized在某些并发场合的性能还是非常高的。</p>
<p>要了解锁的概念，首先要知道管程模型，然后在谈锁的优化。管程是操作系统线程之间的通信原语，是解决多线程同步与互斥的根本。</p>
<h4 id="管程-Monitor"><a href="#管程-Monitor" class="headerlink" title="管程(Monitor)"></a>管程(Monitor)</h4><p>管程(Monitor)，很多文章也翻译为监视器，但是管程更适合，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。管程的发展中，有三个模型：Hasen 模型、Hoare 模型和 MESA 模型，我们这里只说应用最广泛的MESA模型。</p>
<p>管程通过将共享变量以及对共享变量的操作，进行统一的封装来达到资源互斥的目的。对外只提供enq()和deq()进队和出队的操作，当多个线程想要读写共享变量时，同一时刻只能有一个线程进队操作。</p>
<img src="/2020/09/07/concurrent/并发到底怎么来的/monitor.jpg">

<p>在管程模型里，共享变量和对共享变量的操作是被封装起来的，图中最外层的框就代表封装的意思。框的上面只有一个入口，并且在入口旁边还有一个入口等待队列。当多个线程同时试图进入管程内部时，只允许一个线程进入，其他线程则在入口等待队列中等待。</p>
<p>管程里还引入了条件变量的概念，而且每个条件变量都对应有一个等待队列，如下图，条件变量 A 和条件变量 B 分别都有自己的等待队列。</p>
<img src="/2020/09/07/concurrent/并发到底怎么来的/MESA.jpg">

<p>假设有个线程 T1 执行出队操作，不过需要注意的是执行出队操作，有个前提条件，就是队列不能是空的，而队列不空这个前提条件就是管程里的条件变量。 如果线程 T1 进入管程后恰好发现队列是空的，那怎么办呢？等待啊，去哪里等呢？就去条件变量对应的等待队列里面等。此时线程 T1 就去“队列不空”这个条件变量的等待队列中等待。</p>
<p>再假设之后另外一个线程 T2 执行入队操作，入队操作执行成功之后，“队列不空”这个条件对于线程 T1 来说已经满足了，此时线程 T2 要通知 T1，告诉它需要的条件已经满足了。当线程 T1 得到通知后，会从等待队列里面出来，但是出来之后不是马上执行，而是重新进入到入口等待队列里面。</p>
<p>管程中的 wait()、notify()、notifyAll()就是作用于等待通知模型的。</p>
<p>synchronized以及其他排它锁、信号量锁等，底层都是用了管程模型，也就是由操作系统来保证线程之间排斥性的。也正如我们所说的，java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的介入，需要在用户态和核心态之间切换，这种切换会消耗大量的系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。</p>
<ol>
<li>如果线程状态切换是一个高频操作时，这将会消耗很多CPU处理时间；</li>
<li>如果对于那些需要同步的简单的代码块，获取锁挂起操作消耗的时间比用户代码执行的时间还要长，这种同步策略显然非常糟糕的。</li>
</ol>
<p>synchronized会导致争用不到锁的线程进入阻塞状态，所以说它是java语言中一个重量级的同步操纵，被称为重量级锁，为了缓解上述性能问题，JVM从1.5开始，引入了轻量锁与偏向锁，默认启用了自旋锁，他们都属于乐观锁。</p>
<h4 id="synchronized锁优化"><a href="#synchronized锁优化" class="headerlink" title="synchronized锁优化"></a>synchronized锁优化</h4><p>首先我们要先说一下markword。markword是java 对象数据结构中的一部分，我们知道java程序在运行时，会为 JVM单独划分出一块内存区域，而这块内存区域又可以再次划分出一块运行时数据区，运行时数据区域大致可以分为五个部分：</p>
<img src="/2020/09/07/concurrent/并发到底怎么来的/data_area.jpg">

<p>从上面的图中，有两种颜色不同的区域，红色的是线程共享区域，绿色的是线程私有区域，对象就是创建在堆中的。对象在堆中的存储布局可以分为三个部分：</p>
<ol>
<li>对象头：<ol>
<li>第一类信息：存储对象自身的运行时数据，例如哈希吗、GC分代年龄、锁状态标志等等</li>
<li>第二类信息：指针类型，java 虚拟机通过这个指针来确定该对象是哪个类的实例</li>
</ol>
</li>
<li>实例数据：对象真正存储的有效信息</li>
<li>对齐填充：没有实际的意义，起着占位符的作用</li>
</ol>
<p>markword 就是存储对象头第一类信息的数据结构，markword数据的长度在 32 位和 64 位的虚拟机(未开启压缩指针)中分别是32bit和64 bit，它的最后 2bit是锁状态标志位，用来标记当前对象的状态，对象所处的状态，决定了markword存储的内容。</p>
<img src="/2020/09/07/concurrent/并发到底怎么来的/markword_1.jpg">

<p>32位虚拟机在不同状态下markword结构如下图所示：</p>
<img src="/2020/09/07/concurrent/并发到底怎么来的/markword_2.jpg">

<p>synchronized是如何利用markword进行锁优化的呢？</p>
<ol>
<li>如果没有线程竞争，同步块每次只有一个线程执行，那其实不需要加锁。挂一个偏向锁就可以。</li>
<li>如果有多个线程竞争，锁就会升级为轻量级锁(其实就是适应性CAS)，此时还处于用户态。</li>
<li>竞争的线程太多了，导致很多线程长时间无法 CAS 拿到锁，此时锁再次升级为重量级锁，切换到核心态，把锁的管理工作交给管程，所有等待锁的线程将会被阻塞。</li>
</ol>
<p>以上几个步骤，其实就是对 synchronized 的优化过程，注意：只能升锁不能降锁，且synchronized是非公平锁。接下来我们在详细说一下优化的具体过程。</p>
<img src="/2020/09/07/concurrent/并发到底怎么来的/synchronized.jpg">

<p><strong>偏向锁</strong></p>
<p>Java偏向锁(Biased Locking)是Java6引入的一项多线程优化。偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。</p>
<ol>
<li>偏向锁主要用来优化同一线程多次申请同一个锁的竞争，在某些情况下，大部分时间都是同一个线程竞争锁资源</li>
<li>偏向锁的作用<ol>
<li>当一个线程再次访问同一个同步代码时，该线程只需对该对象头的Mark Word中去判断是否有偏向锁指向它</li>
<li>无需再进入Monitor去竞争对象（避免用户态和内核态的切换）</li>
</ol>
</li>
<li>当对象被当做同步锁，并有一个线程抢到锁时<ol>
<li>锁标志位还是01，是否偏向锁标志位设置为1，并且记录抢到锁的线程ID，进入偏向锁状态</li>
</ol>
</li>
<li>偏向锁不会主动释放锁<ol>
<li>当线程1再次获取锁时，会比较当前线程的ID与锁对象头部的线程ID是否一致，如果一致，无需CAS来抢占锁</li>
<li>如果不一致，需要查看锁对象头部记录的线程是否存活<ol>
<li>如果没有存活，那么锁对象被重置为无锁状态（也是一种撤销），然后重新偏向线程2</li>
<li>如果存活，查找线程1的栈帧信息<ol>
<li>如果线程1还是需要继续持有该锁对象，那么暂停线程1（STW stop the world），撤销偏向锁，升级为轻量级锁</li>
<li>如果线程1不再使用该锁对象，那么将该锁对象设为无锁状态（也是一种撤销），然后重新偏向线程2</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>一旦出现其他线程竞争锁资源时，偏向锁就会被撤销<ol>
<li>偏向锁的撤销可能需要等待全局安全点，暂停持有该锁的线程，同时检查该线程是否还在执行该方法</li>
<li>如果还没有执行完，说明此刻有多个线程竞争，升级为轻量级锁；如果已经执行完毕，唤醒其他线程继续CAS抢占</li>
</ol>
</li>
<li>在高并发场景下，当大量线程同时竞争同一个锁资源时，偏向锁会被撤销，发生STW，加大了性能开销<ol>
<li>默认配置<ol>
<li>-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=4000</li>
<li>默认开启偏向锁，并且延迟生效，因为JVM刚启动时竞争非常激烈</li>
</ol>
</li>
<li>关闭偏向锁<ol>
<li>-XX:-UseBiasedLocking</li>
</ol>
</li>
<li>直接设置为重量级锁<ol>
<li>-XX:+UseHeavyMonitors</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>轻量级锁</strong></p>
<ol>
<li>当有另外一个线程竞争锁时，由于该锁处于偏向锁状态</li>
<li>发现对象头Mark Word中的线程ID不是自己的线程ID，该线程就会执行CAS操作获取锁<ol>
<li>如果获取成功，直接替换Mark Word中的线程ID为自己的线程ID，该锁会保持偏向锁状态</li>
<li>如果获取失败，说明当前锁有一定的竞争，将偏向锁升级为轻量级锁</li>
</ol>
</li>
<li>线程获取轻量级锁时会有两步<ol>
<li>先把锁对象的Mark Word复制一份到线程的栈帧中（DisplacedMarkWord），主要为了保留现场</li>
<li>然后使用CAS，把对象头中的内容替换为线程栈帧中DisplacedMarkWord的地址</li>
</ol>
</li>
<li>场景<ol>
<li>在线程1复制对象头Mark Word的同时（CAS之前），线程2也准备获取锁，也复制了对象头Mark Word</li>
<li>在线程2进行CAS时，发现线程1已经把对象头换了，线程2的CAS失败，线程2会尝试使用自旋锁来等待线程1释放锁</li>
</ol>
</li>
<li>轻量级锁的适用场景：线程交替执行同步块，绝大部分的锁在整个同步周期内都不存在长时间的竞争</li>
</ol>
<p><strong>自旋锁 / 重量级锁</strong></p>
<ol>
<li>轻量级锁CAS抢占失败，线程将会被挂起进入阻塞状态。如果正在持有锁的线程在很短的时间内释放锁资源，那么进入阻塞状态的线程被唤醒后又要重新抢占锁资源</li>
<li>JVM提供了自旋锁，可以通过自旋的方式不断尝试获取锁，从而避免线程被挂起阻塞</li>
<li>从JDK 1.7开始，自旋锁默认启用，自旋次数不建议设置过大（意味着长时间占用CPU）</li>
<li>自旋锁重试之后如果依然抢锁失败，同步锁会升级至重量级锁，锁标志位为10。在这个状态下，未抢到锁的线程都会进入Monitor</li>
<li>在锁竞争不激烈且锁占用时间非常短的场景下，自旋锁可以提高系统性能。一旦锁竞争激烈或者锁占用的时间过长，自旋锁将会导致大量的线程一直处于CAS重试状态，占用CPU资源</li>
<li>在高并发的场景下，可以通过关闭自旋锁来优化系统性能<ol>
<li>-XX:-UseSpinning。关闭自旋锁优化</li>
<li>-XX:PreBlockSpin。默认的自旋次数，在JDK 1.7后，由JVM控制</li>
</ol>
</li>
</ol>
<p>大体概括总结如下：</p>
<ol>
<li>JVM在JDK 1.6中引入了分级锁机制来优化synchronized</li>
<li>当一个线程获取锁时，首先对象锁成为一个偏向锁，这是为了避免在同一线程重复获取同一把锁时，用户态和内核态频繁切换</li>
<li>如果有多个线程竞争锁资源，锁将会升级为轻量级锁，这适用于在短时间内持有锁，且分锁交替切换的场景，轻量级锁还结合了自旋锁来避免线程用户态与内核态的频繁切换</li>
<li>如果锁竞争太激烈（自旋锁失败），同步锁会升级为重量级锁</li>
<li>优化synchronized同步锁的关键：减少锁竞争<ol>
<li>应该尽量使synchronized同步锁处于轻量级锁或偏向锁，这样才能提高synchronized同步锁的性能</li>
<li>常用手段<ol>
<li>减少锁粒度：降低锁竞争</li>
<li>减少锁的持有时间，提高synchronized同步锁在自旋时获取锁资源的成功率，避免升级为重量级锁</li>
</ol>
</li>
</ol>
</li>
<li>在锁竞争激烈时，可以考虑禁用偏向锁和禁用自旋锁</li>
</ol>
<p>到此并发的三个问题：可见性、排序性、原子性的产生原因及底层的解决方式就讲完了。剩下的就是 JUC 包中工具类了。</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><blockquote>
<p><a href="https://blog.csdn.net/muxiqingyang/article/details/6615199" target="_blank" rel="noopener">《大话处理器》Cache一致性协议之MESI</a><br><a href="https://juejin.im/post/6844903545653690381" target="_blank" rel="noopener">一文解决内存屏障</a><br><a href="https://zhuanlan.zhihu.com/p/43526907" target="_blank" rel="noopener">volatile与内存屏障总结</a><br><a href="https://monkeysayhi.github.io/2016/11/29/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%81%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">volatile关键字的作用、原理</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU3NDkwMjAyOQ==&mid=100000044&idx=1&sn=7239af3b6a780d615e161094e605d548&chksm=7d2a1b4e4a5d92589484afaa40365ae6b5877438f8bffd55b8e3ecaa57e8a9cd231a4d63a961&mpshare=1&scene=1&srcid=08158JSdNfMYrfE9WYw3heX8&sharer_sharetime=1565836247467&sharer_shareid=c66f994163424339d3cc7514892f0dc2&key=9ba2787c728fb2816050d1b948b5806eb92090879a3cc33d33f99e3b5c6cb5df584450bfa01fe2a8ff8bee1df40351854bbbaec41c82529c9211c84cfdfdcd9534523ca1d2584a2784456e4a1a4ec73d&ascene=1&uin=NjczMzI3MDU%3D&devicetype=Windows+10&version=62060844&lang=zh_CN&pass_ticket=fLWlND%2F4AAA3yqvqbOKXRwkRPKG0x6LnFxX%2FcW%2BLeJQ%3D" target="_blank" rel="noopener">吃透synchronized实现原理</a><br><a href="https://blog.csdn.net/zqz_zqz/article/details/70233767#:~:text=%E5%81%8F%E5%90%91%E9%94%81%E6%98%AF%E5%9C%A8%E6%97%A0,%E9%82%A3%E4%B9%88%E5%BA%94%E8%AF%A5%E7%A6%81%E7%94%A8%E5%81%8F%E5%90%91%E9%94%81%E3%80%82" target="_blank" rel="noopener">java 中的锁 – 偏向锁、轻量级锁、自旋锁、重量级锁</a><br><a href="https://juejin.im/post/6856958647445291021" target="_blank" rel="noopener">别再说自己不会JVM了，看完这篇能和面试官扯上半小时</a><br><a href="http://zhongmingmao.me/2019/08/15/java-performance-synchronized-opt/" target="_blank" rel="noopener">Java性能 – synchronized锁升级优化</a></p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/J-U-C/" rel="tag"># J.U.C</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/23/english/Level4-Unit1/" rel="next" title="Level4.Unit1">
                <i class="fa fa-chevron-left"></i> Level4.Unit1
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/09/07/concurrent/并发魔法类-Unsafe/" rel="prev" title="并发魔法类-Unsafe">
                并发魔法类-Unsafe <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">R.D</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
<br>

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#导读"><span class="nav-number">1.</span> <span class="nav-text">导读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统级优化带来的问题"><span class="nav-number">2.</span> <span class="nav-text">系统级优化带来的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU-结构"><span class="nav-number">2.1.</span> <span class="nav-text">CPU 结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可见性问题的诞生"><span class="nav-number">3.</span> <span class="nav-text">可见性问题的诞生</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存一致性问题"><span class="nav-number">3.1.</span> <span class="nav-text">缓存一致性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MESI-协议"><span class="nav-number">3.1.1.</span> <span class="nav-text">MESI 协议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存一致性问题"><span class="nav-number">3.2.</span> <span class="nav-text">内存一致性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-如何保证内存一致性"><span class="nav-number">3.2.1.</span> <span class="nav-text">volatile 如何保证内存一致性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排序性问题的诞生"><span class="nav-number">4.</span> <span class="nav-text">排序性问题的诞生</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU指令乱序"><span class="nav-number">4.1.</span> <span class="nav-text">CPU指令乱序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DCL"><span class="nav-number">4.1.1.</span> <span class="nav-text">DCL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存屏障-Memory-Barrier-Fence"><span class="nav-number">4.1.2.</span> <span class="nav-text">内存屏障(Memory Barrier/Fence)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译器指令重排"><span class="nav-number">4.2.</span> <span class="nav-text">编译器指令重排</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile如何解决指令重排问题"><span class="nav-number">4.2.1.</span> <span class="nav-text">volatile如何解决指令重排问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Happens-Before原则"><span class="nav-number">4.2.2.</span> <span class="nav-text">Happens-Before原则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子性问题的诞生"><span class="nav-number">5.</span> <span class="nav-text">原子性问题的诞生</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#管程模型与synchronized优化"><span class="nav-number">5.1.</span> <span class="nav-text">管程模型与synchronized优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#管程-Monitor"><span class="nav-number">5.1.1.</span> <span class="nav-text">管程(Monitor)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized锁优化"><span class="nav-number">5.1.2.</span> <span class="nav-text">synchronized锁优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考："><span class="nav-number">6.</span> <span class="nav-text">参考：</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">R.D</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
