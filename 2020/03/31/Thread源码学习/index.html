<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JAVA,Thread,">










<meta name="description" content="线程是程序中的执行线程。Java虚拟机允许应用程序具有多个并发运行的执行线程。">
<meta name="keywords" content="JAVA,Thread">
<meta property="og:type" content="article">
<meta property="og:title" content="Thread源码学习">
<meta property="og:url" content="http://blog.intersico.com/2020/03/31/Thread源码学习/index.html">
<meta property="og:site_name" content="Every Day">
<meta property="og:description" content="线程是程序中的执行线程。Java虚拟机允许应用程序具有多个并发运行的执行线程。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://blog.intersico.com/2020/03/31/Thread源码学习/head.jpg">
<meta property="og:updated_time" content="2020-04-01T10:32:59.821Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Thread源码学习">
<meta name="twitter:description" content="线程是程序中的执行线程。Java虚拟机允许应用程序具有多个并发运行的执行线程。">
<meta name="twitter:image" content="http://blog.intersico.com/2020/03/31/Thread源码学习/head.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.intersico.com/2020/03/31/Thread源码学习/">





  <title>Thread源码学习 | Every Day</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Every Day</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.intersico.com/2020/03/31/Thread源码学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="R.D">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Every Day">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Thread源码学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-31T17:04:58+08:00">
                2020-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA源码/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA源码</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <img src="/2020/03/31/Thread源码学习/head.jpg">

<p>线程是程序中的执行线程。Java虚拟机允许应用程序具有多个并发运行的执行线程。</p>
<a id="more"></a>

<h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure>

<p>每个线程都有一个优先级。具有较高优先级的线程优先于具有较低优先级的线程执行。每个线程可能会也可能不会被标记为守护程序。当在某个线程中运行的代码创建新的Thread对象时，新线程的优先级最初设置为与创建线程的优先级相等，并且当且仅当创建线程是守护程序时，该线程才是守护程序线程。</p>
<p>当Java虚拟机启动时，通常只有一个非守护线程(通常调用某些指定类的名为main的方法)。Java虚拟机将继续执行线程，直到发生以下任何一种情况:</p>
<ul>
<li>调用了 Runtime 类的退出方法，并且安全管理器允许进行退出操作。</li>
<li>不是守护程序线程的所有线程都已死亡，要么通过从调用返回到 run 方法，要么通过抛出传播到 run 方法之外的异常来终止。</li>
</ul>
<p>有两种方法可以创建新的执行线程。一种是将一个类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。然后可以分配并启动子类的实例。例如，计算素数大于指定值的线程可以编写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">long</span> minPrime;</span><br><span class="line"></span><br><span class="line">     PrimeThread(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">         <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">         <span class="comment">//. . .</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码将创建一个线程并使其开始运行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrimeThread p = <span class="keyword">new</span> PrimeThread(<span class="number">143</span>);</span><br><span class="line">p.start();</span><br></pre></td></tr></table></figure>

<p>创建线程的另一种方法是声明一个实现 Runnable 接口的类。然后，该类实现 run 方法。然后可以分配该类的实例，在创建 Thread 时将其作为参数传递并启动。其他样式的相同示例如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">long</span> minPrime;</span><br><span class="line"></span><br><span class="line">     PrimeRun(<span class="keyword">long</span> minPrime) &#123;</span><br><span class="line">         <span class="keyword">this</span>.minPrime = minPrime;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">// compute primes larger than minPrime</span></span><br><span class="line">         <span class="comment">//. . .</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码将创建一个线程并使其开始运行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrimeRun p = <span class="keyword">new</span> PrimeRun(<span class="number">143</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(p).start();</span><br></pre></td></tr></table></figure>

<p>每个线程都有一个名称供识别。一个以上的线程可能具有相同的名称。如果在创建线程时未指定名称，则会为其生成一个新名称。</p>
<p>除非另有说明，否则将 null 参数传递给此类中的构造函数或方法将导致引发 NullPointerException。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p><strong>初始化</strong></p>
<p>一共有八个重载的构造方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public Thread() &#123;</span><br><span class="line">    init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Thread(Runnable target) &#123;</span><br><span class="line">    init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Thread(Runnable target, String name) &#123;</span><br><span class="line">    init(null, target, name, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Thread(String name) &#123;</span><br><span class="line">    init(null, null, name, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Thread(ThreadGroup group, Runnable target) &#123;</span><br><span class="line">    init(group, target, &quot;Thread-&quot; + nextThreadNum(), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Thread(ThreadGroup group, Runnable target, String name) &#123;</span><br><span class="line">    init(group, target, name, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Thread(ThreadGroup group, Runnable target, String name, long stackSize) &#123;</span><br><span class="line">    init(group, target, name, stackSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Thread(ThreadGroup group, String name) &#123;</span><br><span class="line">    init(group, null, name, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的重载构造函数，都是用 init 方法进行初始化，只不过有的参数可以设置为默认值。其中：</p>
<ul>
<li>默认的线程名称为：Thread-N ,这里的 N 为线程编号。</li>
<li>默认的线程优先级等于父线程的优先级</li>
<li>默认的线程模型等于父线程的线程模型(用户线程还是守护线程)</li>
</ul>
<p>当不设置线程名称时，会自动生成线程 ID 对应的线程名称,ID 从 0 开始，并且使用 synchronized 加锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadInitNumber;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextThreadNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> threadInitNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于线程的创建，安全极为重要，包括一个线程对其他线程是否有访问修改权限，某线程是否有对资源访问的权限等。Thread 类通过 SecurityManager 类来对安全权限进行管理。先来看一下 init 初始化方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//线程名称不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取父线程，也就是调用 init 方法的线程。</span></span><br><span class="line">    <span class="comment">//currentThread() 是一个 native 方法</span></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    <span class="comment">//获取安全管理器</span></span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="comment">//获取线程组。每次创建线程，都会加入到对应的线程组中</span></span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* Determine if it's an applet or not */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">           what to do. */</span></span><br><span class="line">        <span class="comment">//如果安全管理器不为空，则使用安全管理器的线程组</span></span><br><span class="line">        <span class="comment">//getThreadGroup() 方法返回线程所属的线程组，如果线程已经死亡，则返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the security doesn't have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">           use the parent thread group. */</span></span><br><span class="line">        <span class="comment">//否则，使用父线程的线程组</span></span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">       explicitly passed in. */</span></span><br><span class="line">    <span class="comment">//查看当前线程是否有修改线程组的权限。</span></span><br><span class="line">    <span class="comment">//在初始化线程、启动线程和销毁线程等操作，都需要在线程组中进行对应的记录，所以需要判断是否具有操作的权限</span></span><br><span class="line">    g.checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Do we have the required permissions?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//当初始化的是 Thread 的子类时，需要判断其子类是否允许覆盖 getContextClassLoader 和 setContextClassLoader 方法</span></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//判断当前类(也就是要创建的线程类)是否具有子类</span></span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            <span class="comment">//如果有，判断是否具有重写的权限</span></span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在线程组中，添加此线程，并设置为未启动状态。其源码在ThreadGroup 中</span></span><br><span class="line">    <span class="comment">//  void addUnstarted() &#123;</span></span><br><span class="line">    <span class="comment">//      synchronized(this) &#123;</span></span><br><span class="line">    <span class="comment">//          if (destroyed) &#123;</span></span><br><span class="line">    <span class="comment">//              throw new IllegalThreadStateException();</span></span><br><span class="line">    <span class="comment">//          &#125;</span></span><br><span class="line">    <span class="comment">//          nUnstartedThreads++; // 未启动线程数加一</span></span><br><span class="line">    <span class="comment">//      &#125;</span></span><br><span class="line">    <span class="comment">//  &#125;</span></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="comment">//默认父线程的线程模型</span></span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="comment">//默认父线程优先级</span></span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="comment">//在上面判断了创建类是否具有子类，这里还要判断父线程是否具有子类。</span></span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="comment">//如果有，判断其子类是否具有拿 ClassLoader 的权限。</span></span><br><span class="line">        <span class="comment">//可以在创建线程时设置上下文 ClassLoader，</span></span><br><span class="line">        <span class="comment">//并允许线程的创建者通过 getContextClassLoader 提供适当的类加载器，</span></span><br><span class="line">        <span class="comment">//以在加载类和资源时在线程中运行代码。</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="comment">//设置访问控制上下文</span></span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">            acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="comment">//实际执行 run 方法的 Runnable 对象</span></span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    <span class="comment">//设置优先级</span></span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="comment">//是否继承 ThreadLocals</span></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">    <span class="comment">//线程内堆栈大小</span></span><br><span class="line">    <span class="comment">//堆栈大小是虚拟机要为此线程的堆栈分配的地址空间的大概字节数。stackSize 参数(如果有)的效果在很大程度上取决于平台。</span></span><br><span class="line">    <span class="comment">//在某些平台上，为 stackSize 参数指定更高的值可能会允许线程在引发 StackOverflowError 之前获得更大的递归深度。</span></span><br><span class="line">    <span class="comment">//类似地，指定一个较低的值可能允许并发存在更多数量的线程，而不会引发 OutOfMemoryError(或其他内部错误)。</span></span><br><span class="line">    <span class="comment">//stackSize 参数的值与最大递归深度和并发级别之间的关系的详细信息取决于平台。</span></span><br><span class="line">    <span class="comment">//在某些平台上，stackSize参数的值可能无效。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//虚拟机可以自由地将 stackSize 参数作为建议。</span></span><br><span class="line">    <span class="comment">//如果平台的指定值过低，则虚拟机可能会使用某些平台特定的最小值</span></span><br><span class="line">    <span class="comment">//如果指定的值过高，则虚拟机可能会使用特定于平台的最大值。</span></span><br><span class="line">    <span class="comment">//同样，虚拟机可以根据需要随意向上或向下舍入指定值(或完全忽略它)。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//由于此构造函数的行为依赖于平台，因此在使用它时应格外小心。</span></span><br><span class="line">    <span class="comment">//从一个 JRE 实现到另一个 JRE 实现，执行给定计算所需的线程堆栈大小可能会有所不同。</span></span><br><span class="line">    <span class="comment">//鉴于这种变化，可能需要仔细调整堆栈大小参数，并且可能需要为运行应用程序的每个 JRE 实现重复进行该调整。</span></span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set thread ID */</span></span><br><span class="line">    <span class="comment">//设置线程 ID</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>启动与中断</strong></p>
<p>线程一共有六个状态：</p>
<ul>
<li>NEW - 尚未启动的线程的线程状态。</li>
<li>RUNNABLE - 可运行线程的线程状态。处于可运行状态的线程正在 Java 虚拟机中执行，但是它可能正在等待来自操作系统(例如处理器)的其他资源。</li>
<li>BLOCKED - 线程的线程状态被阻塞，等待一个监视器锁。处于阻塞状态的线程正在等待一个监视器锁以进入 synchronized 块/方法，或者在调用 Object.wait 方法后，重新进入 synchronized 块/方法</li>
<li>WAITING - 线程处于等待状态，由于调用以下方法之一，线程处于等待状态：<ul>
<li>没有超时的 Object.wait</li>
<li>没有超时的 Thread.join</li>
<li>LockSupport.park<br>处于等待状态的线程正在等待另一个线程执行特定操作。例如，一个在对象上调用 Object.wait() 的线程正在等待另一个线程在该对象上调用 Object.notify() 或 Object.notifyAll()。<br>调用 Thread.join() 的线程正在等待指定的线程终止。</li>
</ul>
</li>
<li>TIMED_WAITING - 具有指定等待时间的等待线程的线程状态。由于以指定的正等待时间调用以下方法之一，因此线程处于定时等待状态：<ul>
<li>Thread.sleep</li>
<li>具有超时的 Object.wait</li>
<li>具有超时的 Thread.join</li>
<li>LockSupport.parkNanos</li>
<li>LockSupport.parkUntil</li>
</ul>
</li>
<li>TERMINATED - 终止线程的线程状态。线程已完成执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使该线程开始执行，Java虚拟机将调用此线程的run方法。</span></span><br><span class="line"><span class="comment">//结果是两个线程同时运行 : 当前线程(从调用返回到 start 方法)和另一个线程(执行其 run 方法)</span></span><br><span class="line"><span class="comment">//一次启动一个线程永远是不合法的。特别是，线程一旦完成执行就可能不会重新启动。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//线程不能重复启动。</span></span><br><span class="line">    <span class="comment">//零状态值对应于状态 "NEW"</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">     * and the group's unstarted count can be decremented. */</span></span><br><span class="line">    <span class="comment">//通知组该线程将要启动，以便可以将其添加到组的线程列表中，并且可以减少该组的未启动计数。</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//启动线程。start0 是 native 方法</span></span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果启动失败，从线程组中删除该线程</span></span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>start()方法启动后，并不是直接执行 run 方法，而是由虚拟机去调用执行 run 方法。看一下 start 中关于 ThreadGroup 的相关操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为空则创建长度为 4 的新线程组</span></span><br><span class="line">        <span class="keyword">if</span> (threads == <span class="keyword">null</span>) &#123;</span><br><span class="line">            threads = <span class="keyword">new</span> Thread[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">//扩容操作，基于数组拷贝</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nthreads == threads.length) &#123;</span><br><span class="line">            threads = Arrays.copyOf(threads, nthreads * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加新线程到线程组</span></span><br><span class="line">        threads[nthreads] = t;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This is done last so it doesn't matter in case the</span></span><br><span class="line">        <span class="comment">// thread is killed</span></span><br><span class="line">        <span class="comment">//活动线程数 +1</span></span><br><span class="line">        nthreads++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The thread is now a fully fledged member of the group, even</span></span><br><span class="line">        <span class="comment">// though it may, or may not, have been started yet. It will prevent</span></span><br><span class="line">        <span class="comment">// the group from being destroyed so the unstarted Threads count is</span></span><br><span class="line">        <span class="comment">// decremented.</span></span><br><span class="line">        <span class="comment">//未启动线程数 -1</span></span><br><span class="line">        nUnstartedThreads--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadStartFailed</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//从线程组数组中，删除此线程</span></span><br><span class="line">        remove(t);</span><br><span class="line">        <span class="comment">//未启动线程 +1</span></span><br><span class="line">        nUnstartedThreads++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从所有活动线程中遍历，删除线程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nthreads ; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (threads[i] == t) &#123;</span><br><span class="line">                    <span class="comment">//找到后，右侧所有元素左移</span></span><br><span class="line">                    System.arraycopy(threads, i + <span class="number">1</span>, threads, i, --nthreads - i);</span><br><span class="line">                    <span class="comment">// Zap dangling reference to the dead thread so that</span></span><br><span class="line">                    <span class="comment">// the garbage collector will collect it.</span></span><br><span class="line">                    <span class="comment">//置空最后一位即可</span></span><br><span class="line">                    threads[nthreads] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>三个与中断相关的方法：interrupt()、interrupted()、isInterrupted()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中断此线程。</span></span><br><span class="line"><span class="comment">//除非当前线程正在中断自己(通常允许这样做)，否则将调用此线程的 checkAccess 方法，这可能会引发 SecurityException。</span></span><br><span class="line"><span class="comment">//如果线程被阻塞在调用 Object 类的 wait()，wait(long)，wait(long,int) 方法或此类的 join()，join(long)，join(long,int)，sleep(long)，sleep(long,int) 方法时，则其中断状态将被清除，并将收到 InterruptedException。</span></span><br><span class="line"><span class="comment">//如果此线程阻塞在 InterruptibleChannel 上的 I/O 操作时，则该通道将关闭，该线程的中断状态将被设置，并且该线程将收到 ClosedByInterruptException。</span></span><br><span class="line"><span class="comment">//如果此线程在 Selector 中被阻塞，则该线程的中断状态将被设置，并且它将立即从 selection 操作中返回，可能具有非零值，就像调用选择器的唤醒方法一样。</span></span><br><span class="line"><span class="comment">//如果以上条件均不成立，则将设置该线程的中断状态。</span></span><br><span class="line"><span class="comment">//中断未激活的线程不会产生任何效果。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当由 A 线程中断 B 线程时，需要判断 A 线程是否具有此操作权限</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">            <span class="comment">//设置中断器,比如有 AbstractInterruptibleChannel 和 AbstractSelector</span></span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                interrupt0(); <span class="comment">// 注意：此中断操作只是设置中断标识，而不是真的中断</span></span><br><span class="line">                b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        interrupt0();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关于中断器设置的代码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Interruptible blocker;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object blockerLock = <span class="keyword">new</span> Object(); <span class="comment">//用来降低加锁粒度的</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">blockedOn</span><span class="params">(Interruptible b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//此处加锁与 interrupt 想呼应</span></span><br><span class="line">        <span class="comment">//赋值时不能中断，中断时不能赋值</span></span><br><span class="line">        <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">            blocker = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>interrupt() 中断方法，只是设置一个中断标识，而并不是真的执行中断操作。这里有一个<strong>需要注意的地方</strong>，如果中断的是 wait、join、sleep 等方法时，其中断状态会被清除，然后返回 InterruptedException 异常。<br>也就是说，本来线程中断，其中断标识应该是 true，但是这里会清除变为 false 并抛出异常，为什么要这么做呢？interrupt 方法不执行实际的中断操作，需要由应用程序自己处理，而既然已经抛出了 InterruptedException 异常，也就没有必要保留标志位了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试当前线程是否已被中断。 </span></span><br><span class="line"><span class="comment">//通过此方法可以清除线程的中断状态。 </span></span><br><span class="line"><span class="comment">//换句话说，如果要连续两次调用此方法，则第二个调用将返回 false(除非在第一个调用清除了其中断状态之后且在第二个调用对其进行检查之前，当前线程再次被中断)。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 interrupted 是一个静态方法，调用此方法会清除中断标识。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>isInterrupted() 与 interrupted() 区别就是不会清除中断标识。他们底层都使用的 native 的 isInterrupted 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>

<p>一个常见的 run 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">//虽然被中断了，但由于清除了标识位，所以仍然返回 false</span></span><br><span class="line">        Thread.currentThread().isInterrupted(); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当线程的 wait 被 interrupt() 方法中断后，会清除其中断标识后抛出 InterruptedException 异常，然后如何处理由应用程序捕获异常后处理。</p>
<p><strong>其他一些方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>实际上，如果想让 yield() 发挥它的作用，需要搭配线程优先级来使用，它的实际运行流程是先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU 的占有权交给此线程，否则继续运行原来的线程。所以 yield() 方法称为“退让”，它把运行机会让给了同等优先级的其他线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clone 操作是不允许的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认有三个优先级，MIN_PRIORITY = 1；NORM_PRIORITY = 5;MAX_PRIORITY = 10;当设置优先级时，如果设置的值大于当前线程组中存在的最大优先级值，那使用这个最大优先级值。<br>也就是不能超过当前线程组中的最大优先级值。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JAVA/" rel="tag"># JAVA</a>
          
            <a href="/tags/Thread/" rel="tag"># Thread</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/28/ConcurrentLinkedQueue源码学习/" rel="next" title="ConcurrentLinkedQueue源码学习">
                <i class="fa fa-chevron-left"></i> ConcurrentLinkedQueue源码学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/01/ThreadLocal源码学习/" rel="prev" title="ThreadLocal源码学习">
                ThreadLocal源码学习 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">R.D</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
<br>

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#简述"><span class="nav-number">1.</span> <span class="nav-text">简述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#源码分析"><span class="nav-number">2.</span> <span class="nav-text">源码分析</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">R.D</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
