<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JUC,">










<meta name="description" content="并发作为 Java 中非常重要的一部分，其内部大量使用了 Unsafe 类，它为 java.util.concurrent 包中的类提供了底层支持。 Unsafe 提供两个功能：  绕过 JVM 直接修改内存（对象） 使用硬件 CPU 指令实现 CAS 原子操作">
<meta name="keywords" content="JUC">
<meta property="og:type" content="article">
<meta property="og:title" content="Unsafe源码学习">
<meta property="og:url" content="http://blog.intersico.com/2020/03/11/concurrent/Unsafe源码学习/index.html">
<meta property="og:site_name" content="Every Day">
<meta property="og:description" content="并发作为 Java 中非常重要的一部分，其内部大量使用了 Unsafe 类，它为 java.util.concurrent 包中的类提供了底层支持。 Unsafe 提供两个功能：  绕过 JVM 直接修改内存（对象） 使用硬件 CPU 指令实现 CAS 原子操作">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://blog.intersico.com/2020/03/11/concurrent/Unsafe源码学习/head.jpg">
<meta property="og:updated_time" content="2020-09-03T08:29:02.970Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Unsafe源码学习">
<meta name="twitter:description" content="并发作为 Java 中非常重要的一部分，其内部大量使用了 Unsafe 类，它为 java.util.concurrent 包中的类提供了底层支持。 Unsafe 提供两个功能：  绕过 JVM 直接修改内存（对象） 使用硬件 CPU 指令实现 CAS 原子操作">
<meta name="twitter:image" content="http://blog.intersico.com/2020/03/11/concurrent/Unsafe源码学习/head.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.intersico.com/2020/03/11/concurrent/Unsafe源码学习/">





  <title>Unsafe源码学习 | Every Day</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Every Day</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.intersico.com/2020/03/11/concurrent/Unsafe源码学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="R.D">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Every Day">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Unsafe源码学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-11T15:39:17+08:00">
                2020-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/并发/" itemprop="url" rel="index">
                    <span itemprop="name">并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <img src="/2020/03/11/concurrent/Unsafe源码学习/head.jpg">

<p>并发作为 Java 中非常重要的一部分，其内部大量使用了 Unsafe 类，它为 java.util.concurrent 包中的类提供了底层支持。</p>
<p>Unsafe 提供两个功能：</p>
<ul>
<li>绕过 JVM 直接修改内存（对象）</li>
<li>使用硬件 CPU 指令实现 CAS 原子操作</li>
</ul>
<a id="more"></a>

<blockquote>
<p>本文转载自 <a href="https://my.oschina.net/editorial-story/blog/3019773" target="_blank" rel="noopener">JDK Unsafe 源码完全注释</a><br>在此只是记录下这篇文章，方便日后查看学习，非常感谢作者的文章。</p>
</blockquote>
<h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>Unsafe 并不是 JDK 的标准，它是 Sun 的内部实现，存在于 sun.misc 包中，在 Oracle 发行的 JDK 中并不包含其源代码。</p>
<p>虽然我们在一般的并发编程中不会直接用到 Unsafe，但是很多 Java 基础类库与诸如 Netty、Cassandra 和 Kafka 等高性能库都采用它，它在提升 Java 运行效率、增强 Java 语言底层操作能力方面起了很大作用。本文将深入到 Unsafe 的源码，分析一下它的逻辑。</p>
<p>本文使用 OpenJDK（jdk8-b120）中 Unsafe 的源码，Unsafe 的实现是和虚拟机实现相关的，不同的虚拟机实现，它们的对象结构可能不一样，这个 Unsafe 只能用于 Hotspot 虚拟机。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p><a href="http://hg.openjdk.java.net/jdk/jdk/file/a1ee9743f4ee/jdk/src/share/classes/sun/misc/Unsafe.java" target="_blank" rel="noopener">源码查看</a></p>
<p>Unsafe 为调用者提供执行非安全操作的能力，由于返回的 Unsafe 对象可以读写任意的内存地址数据，调用者应该小心谨慎的使用该对象，一定不能把它传递到非信任代码。该类的大部分方法都是非常底层的操作，并牵涉到一小部分典型的机器都包含的硬件指令，编译器可以对这些进行优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">        sun.reflect.Reflection.registerMethodsToFilter(Unsafe.class, <span class="string">"getUnsafe"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Unsafe</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe = <span class="keyword">new</span> Unsafe();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (!VM.isSystemDomainLoader(caller.getClassLoader()))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码包含如下功能:</p>
<ul>
<li>本地静态方法：registerNatives()，该方法会在静态块中执行</li>
<li>私有构造函数：该类实例是单例的，不能实例化，可以通过 getUnsafe() 方法获取实例</li>
<li>静态单例方法：getUnsafe()，获取实例</li>
<li>静态块：包含初始化的注册功能</li>
</ul>
<p>要使用此类必须获得其实例，获得实例的方法是 getUnsafe()，那就先看看这个方法。</p>
<p>getUnsafe() 方法包含一个注释 @CallerSensitive，说明该方法不是谁都可以调用的。如果调用者不是由系统类加载器（bootstrap classloader）加载，则将抛出 SecurityException，所以默认情况下，应用代码调用此方法将抛出异常。我们的代码要想通过 getUnsafe() 获取实例是不可能的了，不过可通过反射获取 Unsafe 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field f= Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">U= (Unsafe) f.get(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>此处通过反射获取类的静态字段，这样就绕过了 getUnsafe() 的安全限制。</p>
<p>也可以通过反射获取构造方法再实例化，但这样违法了该类单例的原则，并且在使用上可能会有其它问题，所以不建议这样做。</p>
<p>再来看看如何获取指定变量的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>

<p>获取指定对象中指定偏移量的字段或数组元素的值，参数 o 是变量关联的 Java 堆对象，如果指定的对象为 null，则获取内存中该地址的值（即 offset 为内存绝对地址）。</p>
<p>如果不符合以下任意条件，则该方法返回的值是不确定的：</p>
<ul>
<li>offset 通过 objectFieldOffset 方法获取的类的某一字段的偏移量，并且关联的对象 o 是该类的兼容对象（对象 o 所在的类必须是该类或该类的子类）</li>
<li>offset 通过 staticFieldOffset 方法获取的类的某一字段的偏移量，o 是通过 staticFieldBase 方法获取的对象</li>
<li>如果 o 引用的是数组，则 offset 的值为 B+N*S，其中 N 是数组的合法下标，B 是通过 arrayBaseOffset 方法从该数组类获取的，S 是通过 arrayIndexScale 方法从该数组类获取的</li>
</ul>
<p>如果以上任意条件符合，则调用者能获取 Java 字段的引用，但是如果该字段的类型和该方法返回的类型不一致，则结果是不一定的，比如该字段是 short，但调用了 getInt 方法。</p>
<p>该方法通过两个参数引用一个变量，它为 Java 变量提供 double-register 地址模型。如果引用的对象为 null，则该方法将 offset 当作内存绝对地址，就像 getInt(long)一样，它为非 Java 变量提供 single-register 地址模型，然而 Java 变量的内存布局可能和非 Java 变量的内存布局不同，不应该假设这两种地址模型是相等的。同时，应该记住 double-register 地址模型的偏移量不应该和 single-register 地址模型中的地址（long 参数）混淆。</p>
<p>再看条件中提到的几个相关方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(Field f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">staticFieldBase</span><span class="params">(Field f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">staticFieldOffset</span><span class="params">(Field f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayBaseOffset</span><span class="params">(Class arrayClass)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayIndexScale</span><span class="params">(Class arrayClass)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这几个方法分别是获取静态字段、非静态字段与数组字段的一些信息。</p>
<p><strong>objectFieldOffset</strong></p>
<p>很难想象 JVM 需要使用这么多比特位来编码非数组对象的偏移量，为了和该类的其它方法保持一致，所以该方法也返回 long 类型。</p>
<p><strong>staticFieldBase</strong></p>
<p>获取指定静态字段的位置，和 staticFieldOffset 一起使用。获取该静态字段所在的“对象”可通过类似 getInt(Object,long)的方法访问。</p>
<p><strong>staticFieldOffset</strong></p>
<p>返回给定的字段在该类的偏移地址。对于任何给定的字段，该方法总是返回相同的值，同一个类的不同字段总是返回不同的值。从 1.4.1 开始，字段的偏移以 long 表示，虽然 Sun 的 JVM 只使用了 32 位，但是那些将静态字段存储到绝对地址的 JVM 实现需要使用 long 类型的偏移量，通过 getXX(null,long) 获取字段值，为了保持代码迁移到 64 位平台上 JVM 的优良性，必须保持静态字段偏移量的所有比。</p>
<p><strong>arrayBaseOffset</strong></p>
<p>返回给定数组类第一个元素在内存中的偏移量。如果 arrayIndexScale 方法返回非 0 值，要获得访问数组元素的新的偏移量，则需要使用 s。</p>
<p><strong>arrayIndexScale</strong></p>
<p>返回给定数组类的每个元素在内存中的 scale(所占用的字节)。然而对于“narrow”类型的数组，类似 getByte(Object, int)的访问方法一般不会获得正确的结果，所以这些类返回的 scale 会是 0。</p>
<p>下边用代码解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObj</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> objField=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> clsField=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span>[] array=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> Unsafe U;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Field f= Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        U= (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个类包含成员变量 objField、类变量 clsField、成员数组 array 用于实验。要获取正确的结果，必须满足注释里的三个条件之一：</p>
<p>1、offset 通过 objectFieldOffset 方法获取的类的某一字段的偏移量，并且关联的对象 o 是该类的兼容对象(对象 o 所在的类必须是该类或该类的子类)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObjChild</span> <span class="keyword">extends</span> <span class="title">MyObj</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> anthor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getObjFieldVal</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">    Field field=MyObj.class.getDeclaredField(<span class="string">"objField"</span>);</span><br><span class="line">    <span class="keyword">long</span> offset= U.objectFieldOffset(field);</span><br><span class="line">    MyObj obj=<span class="keyword">new</span> MyObj();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val= U.getInt(obj,offset);</span><br><span class="line">    System.out.println(<span class="string">"1.\t"</span>+(val==<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    MyObjChild child=<span class="keyword">new</span> MyObjChild();</span><br><span class="line">    <span class="keyword">int</span> corVal1= U.getInt(child,offset);</span><br><span class="line">    System.out.println(<span class="string">"2.\t"</span>+(corVal1==<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    Field fieldChild=MyObjChild.class.getDeclaredField(<span class="string">"objField"</span>);</span><br><span class="line">    <span class="keyword">long</span> offsetChild= U.objectFieldOffset(fieldChild);</span><br><span class="line">    System.out.println(<span class="string">"3.\t"</span>+(offset==offsetChild));</span><br><span class="line">    <span class="keyword">int</span> corVal2= U.getInt(obj,offsetChild);</span><br><span class="line">    System.out.println(<span class="string">"4.\t"</span>+(corVal2==<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> errVal1=U.getShort(obj,offset);</span><br><span class="line">    System.out.println(<span class="string">"5.\t"</span>+(errVal1==<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> errVal2=U.getInt(<span class="string">"abcd"</span>,offset);</span><br><span class="line">    System.out.println(<span class="string">"6.\t"</span>+errVal2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">-<span class="number">223271518</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数 o 和 offset 都是从 MyObj 获取的，所以返回 true。</li>
<li>第二个参数 o 是 MyObjChild 的实例，MyObjChild 是 MyObj 的子类，对象 o 是 MyObj 的兼容实例，所以返回 true。这从侧面说明在虚拟机中子类的实例的内存结构继承了父类的实例的内存结构。</li>
<li>第三个比较子类和父类中获取的字段偏移量是否相同，返回 true 说明是一样的，既然是一样的，第四个自然就返回 true。</li>
</ul>
<p>这里重点说一下第五个，objField 是一个 int 类型，占四个字节，其值为 10，二进制为 00000000 00000000 00000000 00001010。Intel 处理器读取内存使用的是小端（Little-Endian）模式，在使用 Intel 处理器的机器的内存中多字节类型是按小端存储的，即低位在内存的低字节存储，高位在内存的高字节存储，所以 int 10 在内存中是（offset 0-3） 00001010 00000000 00000000 00000000。使用 getShort 会读取两个字节，即 00001010 00000000，获取的值仍为 10。</p>
<p>但是某些处理器是使用大端（Big-Endian），如 ARM 支持小端和大端，使用此处理器的机器的内存就会按大端存储多字节类型，与小端相反，此模式下低位在内存的高字节存储，高位在内存的低字节存储，所以 int 10 在内存中是（offset 0-3）00000000 00000000 00000000 00001010。在这种情况下，getShort 获取的值将会是 0。</p>
<p>不同的机器可能产生不一样的结果，基于此情况，如果字段是 int 类型，但需要一个 short 类型，也不应该调用 getShort，而应该调用 getInt，然后强制转换成 short。此外，如果调用 getLong，该方法返回的值一定不是 10。就像方法注释所说，调用该类型方法时，要保证方法的返回值和字段的值是同一种类型。</p>
<p>第六个测试获取非 MyObj 实例的偏移位置的值，这种情况下代码本身并不会报错，但获取到的值并非该字段的值（未定义的值）</p>
<p>2、offset 通过 staticFieldOffset 方法获取的类的某一字段的偏移量，o 是通过 staticFieldBase 方法获取的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getClsFieldVal</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">    Field field=MyObj.class.getDeclaredField(<span class="string">"clsField"</span>);</span><br><span class="line">    <span class="keyword">long</span> offset= U.staticFieldOffset(field);</span><br><span class="line">    Object obj=U.staticFieldBase(field);</span><br><span class="line">    <span class="keyword">int</span> val1=U.getInt(MyObj.class,offset);</span><br><span class="line">    System.out.println(<span class="string">"1.\t"</span>+(val1==<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">int</span> val2=U.getInt(obj,offset);</span><br><span class="line">    System.out.println(<span class="string">"2.\t"</span>+(val2==<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>获取静态字段的值，有两个方法：staticFieldBase 获取字段所在的对象，静态字段附着于 Class 本身（java.lang.Class 的实例），该方法返回的其实就是该类本身，本例中是 MyObj.class。</p>
<p>3、如果 o 引用的是数组，则 offset 的值为 B+N*S，其中 N 是数组的合法的下标，B 是通过 arrayBaseOffset 方法从该数组类获取的，S 是通过 arrayIndexScale 方法从该数组类获取的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getArrayVal</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> expectedVal)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> base=U.arrayBaseOffset(<span class="keyword">int</span>[].class);</span><br><span class="line">    <span class="keyword">int</span> scale=U.arrayIndexScale(<span class="keyword">int</span>[].class);</span><br><span class="line">    MyObj obj=<span class="keyword">new</span> MyObj();</span><br><span class="line">    Field field=MyObj.class.getDeclaredField(<span class="string">"array"</span>);</span><br><span class="line">    <span class="keyword">long</span> offset= U.objectFieldOffset(field);</span><br><span class="line">    <span class="keyword">int</span>[] array= (<span class="keyword">int</span>[]) U.getObject(obj,offset);</span><br><span class="line">    <span class="keyword">int</span> val1=U.getInt(array,(<span class="keyword">long</span>)base+index*scale);</span><br><span class="line">    System.out.println(<span class="string">"1.\t"</span>+(val1==expectedVal));</span><br><span class="line">    <span class="keyword">int</span> val2=U.getInt(obj.array,(<span class="keyword">long</span>)base+index*scale);</span><br><span class="line">    System.out.println(<span class="string">"2.\t"</span>+(val2==expectedVal));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getArrayVal(<span class="number">2</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>获取数组的值以及获取数组中某下标的值。获取数组某一下标的偏移量有一个计算公式 B+N*S，B 是数组元素在数组中的基准偏移量，S 是每个元素占用的字节数，N 是数组元素的下标。</p>
<p>有个要注意的地方，上面例子中方法内的数组的 offset 和 base 是两个完全不同的偏移量，offset 是数组 array 在对象 obj 中的偏移量，base 是数组元素在数组中的基准偏移量，这两个值没有任何联系，不能通过 offset 推导出 base。</p>
<p>getInt 的参数 o 可以是 null，在这种情况下，其和方法 getInt(long) 就是一样的了，offset 就不是表示相对的偏移地址了，而是表示内存中的绝对地址。操作系统中，一个进程是不能访问其他进程的内存的，所以传入 getInt 中的绝对地址必须是当前 JVM 管理的内存地址，否则进程会退出。</p>
<p>下一个方法，将值存储到 Java 变量中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>前两个参数会被解释成 Java 变量（字段或数组）的引用</li>
<li>参数给定的值会被存储到该变量，变量的类型必须和方法参数的类型一致</li>
<li>参数 o 是变量关联的 Java 堆对象，可以为 null</li>
<li>参数 offset 代表该变量在该对象的位置，如果 o 是 null 则是内存的绝对地址</li>
</ul>
<p>修改指定位置的内存，测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setObjFieldVal</span><span class="params">(<span class="keyword">int</span> val)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">        Field field=MyObj.class.getDeclaredField(<span class="string">"objField"</span>);</span><br><span class="line">        <span class="keyword">long</span> offset= U.objectFieldOffset(field);</span><br><span class="line">        MyObj obj=<span class="keyword">new</span> MyObj();</span><br><span class="line">        U.putInt(obj,offset,val);</span><br><span class="line">        <span class="keyword">int</span> getVal= U.getInt(obj,offset);</span><br><span class="line">        System.out.println(val==getVal);</span><br><span class="line">        U.putLong(obj,offset,val);</span><br><span class="line">        Field fieldArray=MyObj.class.getDeclaredField(<span class="string">"array"</span>);</span><br><span class="line">        <span class="keyword">long</span> offsetArray= U.objectFieldOffset(fieldArray);</span><br><span class="line"><span class="comment">//        int[] array= (int[]) U.getObject(obj,offsetArray);</span></span><br><span class="line"><span class="comment">//        for(int i=0;i&lt;array.length;i++)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(array[i]);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>objField 是 int 类型，通过 putInt 修改 objField 的值可以正常修改，结果打印 true。然后使用 putLong 修改 objField 的值，这个修改操作本身也不会报错，但是 objField 并不是 long 类型，这样修改会导致其它程序错误，它不仅修改了 objField 的内存值，还修改了 objField 之后四个字节的内存值。</p>
<p>在这个例子中，objField 后面八个字节存储的是 array 字段所表示的数组对象的偏移位置，但是被修改了，如果后面的代码尝试访问 array 字段就会出错。修改其它字段（array、clsField）也是一样的，只要按之前的方法获取字段的偏移位置，使用与字段类型一致的 put 方法就可以。</p>
<p>下面的方法都是差不多的，只是针对不同的数据类型或者兼容 1.4 的字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putBoolean</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">boolean</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">byte</span>    <span class="title">getByte</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putByte</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">byte</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">short</span>   <span class="title">getShort</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putShort</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">short</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">char</span>    <span class="title">getChar</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putChar</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">char</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span>    <span class="title">getLong</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">float</span>   <span class="title">getFloat</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putFloat</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">float</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">double</span>  <span class="title">getDouble</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putDouble</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">double</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Object o, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getInt(o, (<span class="keyword">long</span>)offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putInt</span><span class="params">(Object o, <span class="keyword">int</span> offset, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    putInt(o, (<span class="keyword">long</span>)offset, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object o, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getObject(o, (<span class="keyword">long</span>)offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object o, <span class="keyword">int</span> offset, Object x)</span> </span>&#123;</span><br><span class="line">    putObject(o, (<span class="keyword">long</span>)offset, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(Object o, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getBoolean(o, (<span class="keyword">long</span>)offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putBoolean</span><span class="params">(Object o, <span class="keyword">int</span> offset, <span class="keyword">boolean</span> x)</span> </span>&#123;</span><br><span class="line">    putBoolean(o, (<span class="keyword">long</span>)offset, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(Object o, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getByte(o, (<span class="keyword">long</span>)offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putByte</span><span class="params">(Object o, <span class="keyword">int</span> offset, <span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">    putByte(o, (<span class="keyword">long</span>)offset, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">getShort</span><span class="params">(Object o, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getShort(o, (<span class="keyword">long</span>)offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putShort</span><span class="params">(Object o, <span class="keyword">int</span> offset, <span class="keyword">short</span> x)</span> </span>&#123;</span><br><span class="line">    putShort(o, (<span class="keyword">long</span>)offset, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">(Object o, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getChar(o, (<span class="keyword">long</span>)offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putChar</span><span class="params">(Object o, <span class="keyword">int</span> offset, <span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">    putChar(o, (<span class="keyword">long</span>)offset, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">(Object o, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getLong(o, (<span class="keyword">long</span>)offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putLong</span><span class="params">(Object o, <span class="keyword">int</span> offset, <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    putLong(o, (<span class="keyword">long</span>)offset, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(Object o, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFloat(o, (<span class="keyword">long</span>)offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putFloat</span><span class="params">(Object o, <span class="keyword">int</span> offset, <span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">    putFloat(o, (<span class="keyword">long</span>)offset, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(Object o, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getDouble(o, (<span class="keyword">long</span>)offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putDouble</span><span class="params">(Object o, <span class="keyword">int</span> offset, <span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    putDouble(o, (<span class="keyword">long</span>)offset, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的方法和上面的也类似，只是这些方法只有一个参数，即内存绝对地址，这些方法不需要 Java 对象地址作为基准地址，所以它们可以作用于本地方法区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取内存地址的值，如果地址是 0 或者不是指向通过 allocateMemory 方法获取的内存块，则结果是未知的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">byte</span>    <span class="title">getByte</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个值写入内存，如果地址是 0 或者不是指向通过 allocateMemory 方法获取的内存块，则结果是未知的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putByte</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">byte</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">short</span>   <span class="title">getShort</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putShort</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">short</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">char</span>    <span class="title">getChar</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putChar</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">char</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span>     <span class="title">getInt</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putInt</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span>    <span class="title">getLong</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putLong</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">float</span>   <span class="title">getFloat</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putFloat</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">float</span> x)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">double</span>  <span class="title">getDouble</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putDouble</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这里提到一个方法 allocateMemory，它是用于分配本地内存的。看看和本地内存有关的几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///包装malloc，realloc，free</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配指定大小的一块本地内存。分配的这块内存不会初始化，它们的内容通常是没用的数据</span></span><br><span class="line"><span class="comment"> * 返回的本地指针不会是 0，并且该内存块是连续的。调用 freeMemory 方法可以释放此内存，调用</span></span><br><span class="line"><span class="comment"> * reallocateMemory 方法可以重新分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重新分配一块指定大小的本地内存，超出老内存块的字节不会被初始化，它们的内容通常是没用的数据</span></span><br><span class="line"><span class="comment"> * 当且仅当请求的大小为 0 时，该方法返回的本地指针会是 0。</span></span><br><span class="line"><span class="comment"> * 该内存块是连续的。调用 freeMemory 方法可以释放此内存，调用 reallocateMemory 方法可以重新分配</span></span><br><span class="line"><span class="comment"> * 参数 address 可以是 null，这种情况下会分配新内存(和 allocateMemory 一样)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">reallocateMemory</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 将给定的内存块的所有字节设置成固定的值(通常是 0)</span></span><br><span class="line"><span class="comment"> * 该方法通过两个参数确定内存块的基准地址，就像在 getInt(Object,long) 中讨论的，它提供了 double-register 地址模型</span></span><br><span class="line"><span class="comment"> * 如果引用的对象是 null, 则 offset 会被当成绝对基准地址</span></span><br><span class="line"><span class="comment"> * 该写入操作是按单元写入的，单元的字节大小由地址和长度参数决定，每个单元的写入是原子性的。如果地址和长度都是 8 的倍数，则一个单元为 long</span></span><br><span class="line"><span class="comment"> * 型(一个单元 8 个字节)；如果地址和长度都是 4 的倍数，则一个单元为 int 型(一个单元 4 个字节)；</span></span><br><span class="line"><span class="comment"> * 如果地址和长度都是 2 的倍数，则一个单元为 short 型(一个单元 2 个字节)；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> bytes, <span class="keyword">byte</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将给定的内存块的所有字节设置成固定的值(通常是 0)</span></span><br><span class="line"><span class="comment">//就像在 getInt(Object,long) 中讨论的，该方法提供 single-register 地址模型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> bytes, <span class="keyword">byte</span> value)</span> </span>&#123;</span><br><span class="line">    setMemory(<span class="keyword">null</span>, address, bytes, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//复制指定内存块的字节到另一内存块</span></span><br><span class="line"><span class="comment">//该方法的两个基准地址分别由两个参数决定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">copyMemory</span><span class="params">(Object srcBase, <span class="keyword">long</span> srcOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Object destBase, <span class="keyword">long</span> destOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制指定内存块的字节到另一内存块，但使用 single-register 地址模型</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyMemory</span><span class="params">(<span class="keyword">long</span> srcAddress, <span class="keyword">long</span> destAddress, <span class="keyword">long</span> bytes)</span> </span>&#123;</span><br><span class="line">    copyMemory(<span class="keyword">null</span>, srcAddress, <span class="keyword">null</span>, destAddress, bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放通过 allocateMemory 或者 reallocateMemory 获取的内存，如果参数 address 是 null，则不做任何处理</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br></pre></td></tr></table></figure>

<p>allocateMemory、reallocateMemory、freeMemory 与 setMemory 分别是对 C 函数 malloc、realloc、free 和 memset 的封装，这样该类就提供了动态获取/释放本地方法区内存的功能。</p>
<ul>
<li>malloc 用于分配一个全新的未使用的连续内存，但该内存不会初始化，即不会被清零；</li>
<li>realloc 用于内存的缩容或扩容，有两个参数，从 malloc 返回的地址和要调整的大小，该函数和 malloc 一样，不会初始化，它能保留之前放到内存里的值，很适合用于扩容；</li>
<li>free 用于释放内存，该方法只有一个地址参数，那它如何知道要释放多少个字节呢？其实在 malloc 分配内存的时候会多分配 4 个字节用于存放该块的长度，比如 malloc(10) 其实会花费 14 个字节。理论上讲能分配的最大内存是 4G（2^32-1）。在 hotspot 虚拟机的设计中，数组对象也有 4 个字节用于存放数组长度，那么在 hotspot 中，数组的最大长度就是 2^32-1，这样 free 函数只要读取前 4 个字节就知道要释放多少内存了（10+4）；</li>
<li>memset  一般用于初始化内存，可以设置初始化内存的值，一般初始值会设置成 0，即清零操作。</li>
</ul>
<p>来一个简单的例子，<strong>申请内存-写入内存-读取内存-释放内存：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> address=U.allocateMemory(<span class="number">10</span>);</span><br><span class="line">U.setMemory(address,<span class="number">10</span>,(<span class="keyword">byte</span>)<span class="number">1</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1的二进制码为00000001，int为四个字节，U.getInt将读取四个字节，</span></span><br><span class="line"><span class="comment"> * 读取的字节为00000001 00000001 00000001 00000001</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0b00000001000000010000000100000001</span>;</span><br><span class="line">System.out.println(i==U.getInt(address));</span><br><span class="line">U.freeMemory(address);</span><br></pre></td></tr></table></figure>

<p>接下来看看获取类变量相关信息的几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// random queries</span></span><br><span class="line"><span class="comment">/// 随机搜索，对象是放在一块连续的内存空间中，所以是支持随机搜索的</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * staticFieldOffset，objectFieldOffset，arrayBaseOffset 方法的返回值不会是该常量(-1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INVALID_FIELD_OFFSET   = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回字段的偏移量，32 字节</span></span><br><span class="line"><span class="comment"> * 从 1.4.1 开始，对于静态字段，请使用 staticFieldOffset 方法，非静态字段使用 objectFieldOffset 方法获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fieldOffset</span><span class="params">(Field f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Modifier.isStatic(f.getModifiers()))</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) staticFieldOffset(f);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) objectFieldOffset(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回用于访问静态字段的基准地址</span></span><br><span class="line"><span class="comment"> * 从 1.4.1 开始，要获取访问指定字段的基准地址，请使用 staticFieldBase(Field)</span></span><br><span class="line"><span class="comment"> * 该方法仅能作用于把所有静态字段放在一起的 JVM 实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">staticFieldBase</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Field[] fields = c.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Modifier.isStatic(fields[i].getModifiers())) &#123;</span><br><span class="line">            <span class="keyword">return</span> staticFieldBase(fields[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回给定的字段在该类的偏移地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 对于任何给定的字段，该方法总是返回相同的值；同一个类的不同字段总是返回不同的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 从 1.4.1 开始，字段的偏移以 long 表示，虽然 Sun 的 JVM 只使用了 32 位，但是那些将静态字段存储到绝对地址的 JVM 实现</span></span><br><span class="line"><span class="comment"> * 需要使用 long 类型的偏移量，通过 getXX(null,long) 获取字段值，为了保持代码迁移到 64 位平台上 JVM 的优良性，</span></span><br><span class="line"><span class="comment"> * 必须保持静态字段偏移量的所有比特位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">staticFieldOffset</span><span class="params">(Field f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 很难想象 JVM 需要使用这么多比特位来编码非数组对象的偏移量，它们只需要很少的比特位就可以了(有谁看过有100个成员变量的类么？</span></span><br><span class="line"><span class="comment"> * 一个字节能表示 256 个成员变量)，</span></span><br><span class="line"><span class="comment"> * 为了和该类的其他方法保持一致，所以该方法也返回 long 类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(Field f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定静态字段的位置，和 staticFieldOffset 一起使用</span></span><br><span class="line"><span class="comment"> * 获取该静态字段所在的"对象"，这个"对象"可通过类似 getInt(Object,long) 的方法访问</span></span><br><span class="line"><span class="comment"> * 该"对象"可能是 null，并且引用的可能是对象的"cookie"(此处cookie具体含义未知，没有找到相关资料)，不保证是真正的对象，该"对象"只能当作此类中 put 和 get 方法的参数，</span></span><br><span class="line"><span class="comment"> * 其他情况下不应该使用它</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">staticFieldBase</span><span class="params">(Field f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查给定的类是否需要初始化，它通常和 staticFieldBase 方法一起使用</span></span><br><span class="line"><span class="comment"> * 只有当 ensureClassInitialized 方法不产生任何影响时才会返回 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">shouldBeInitialized</span><span class="params">(Class&lt;?&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确保给定的类已被初始化，它通常和 staticFieldBase 方法一起使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">ensureClassInitialized</span><span class="params">(Class&lt;?&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回给定数组类第一个元素在内存中的偏移量，如果 arrayIndexScale 方法返回非0值，要获得访问数组元素的新的偏移量，</span></span><br><span class="line"><span class="comment"> * 需要使用 scale</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayBaseOffset</span><span class="params">(Class&lt;?&gt; arrayClass)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The value of &#123;<span class="doctag">@code</span> arrayBaseOffset(boolean[].class)&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_BOOLEAN_BASE_OFFSET</span><br><span class="line">        = theUnsafe.arrayBaseOffset(<span class="keyword">boolean</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The value of &#123;<span class="doctag">@code</span> arrayBaseOffset(byte[].class)&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_BYTE_BASE_OFFSET</span><br><span class="line">        = theUnsafe.arrayBaseOffset(<span class="keyword">byte</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The value of &#123;<span class="doctag">@code</span> arrayBaseOffset(short[].class)&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_SHORT_BASE_OFFSET</span><br><span class="line">        = theUnsafe.arrayBaseOffset(<span class="keyword">short</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The value of &#123;<span class="doctag">@code</span> arrayBaseOffset(char[].class)&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_CHAR_BASE_OFFSET</span><br><span class="line">        = theUnsafe.arrayBaseOffset(<span class="keyword">char</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The value of &#123;<span class="doctag">@code</span> arrayBaseOffset(int[].class)&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_INT_BASE_OFFSET</span><br><span class="line">        = theUnsafe.arrayBaseOffset(<span class="keyword">int</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The value of &#123;<span class="doctag">@code</span> arrayBaseOffset(long[].class)&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_LONG_BASE_OFFSET</span><br><span class="line">        = theUnsafe.arrayBaseOffset(<span class="keyword">long</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The value of &#123;<span class="doctag">@code</span> arrayBaseOffset(float[].class)&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_FLOAT_BASE_OFFSET</span><br><span class="line">        = theUnsafe.arrayBaseOffset(<span class="keyword">float</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The value of &#123;<span class="doctag">@code</span> arrayBaseOffset(double[].class)&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_DOUBLE_BASE_OFFSET</span><br><span class="line">        = theUnsafe.arrayBaseOffset(<span class="keyword">double</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The value of &#123;<span class="doctag">@code</span> arrayBaseOffset(Object[].class)&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_OBJECT_BASE_OFFSET</span><br><span class="line">        = theUnsafe.arrayBaseOffset(Object[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回给定数组类的每个元素在内存中的 scale(所占用的字节)。然而对于"narrow"类型的数组，类似 getByte(Object, int) 的访问方法</span></span><br><span class="line"><span class="comment"> * 一般不会获得正确的结果，所以这些类返回的 scale 会是 0</span></span><br><span class="line"><span class="comment"> * (本人水平有限，此处narrow类型不知道具体含义，不了解什么时候此方法会返回0)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayIndexScale</span><span class="params">(Class&lt;?&gt; arrayClass)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The value of &#123;<span class="doctag">@code</span> arrayIndexScale(boolean[].class)&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_BOOLEAN_INDEX_SCALE</span><br><span class="line">        = theUnsafe.arrayIndexScale(<span class="keyword">boolean</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The value of &#123;<span class="doctag">@code</span> arrayIndexScale(byte[].class)&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_BYTE_INDEX_SCALE</span><br><span class="line">        = theUnsafe.arrayIndexScale(<span class="keyword">byte</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The value of &#123;<span class="doctag">@code</span> arrayIndexScale(short[].class)&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_SHORT_INDEX_SCALE</span><br><span class="line">        = theUnsafe.arrayIndexScale(<span class="keyword">short</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The value of &#123;<span class="doctag">@code</span> arrayIndexScale(char[].class)&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_CHAR_INDEX_SCALE</span><br><span class="line">        = theUnsafe.arrayIndexScale(<span class="keyword">char</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The value of &#123;<span class="doctag">@code</span> arrayIndexScale(int[].class)&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_INT_INDEX_SCALE</span><br><span class="line">        = theUnsafe.arrayIndexScale(<span class="keyword">int</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The value of &#123;<span class="doctag">@code</span> arrayIndexScale(long[].class)&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_LONG_INDEX_SCALE</span><br><span class="line">        = theUnsafe.arrayIndexScale(<span class="keyword">long</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The value of &#123;<span class="doctag">@code</span> arrayIndexScale(float[].class)&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_FLOAT_INDEX_SCALE</span><br><span class="line">        = theUnsafe.arrayIndexScale(<span class="keyword">float</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The value of &#123;<span class="doctag">@code</span> arrayIndexScale(double[].class)&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_DOUBLE_INDEX_SCALE</span><br><span class="line">        = theUnsafe.arrayIndexScale(<span class="keyword">double</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The value of &#123;<span class="doctag">@code</span> arrayIndexScale(Object[].class)&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ARRAY_OBJECT_INDEX_SCALE</span><br><span class="line">        = theUnsafe.arrayIndexScale(Object[].class);</span><br></pre></td></tr></table></figure>

<p>上面的一些方法之前已经提到过，注释也说的比较明白, 说一下 shouldBeInitialized 和 ensureClassInitialized，shouldBeInitialized 判断类是否已初始化，ensureClassInitialized 执行初始化。有个概念需要了解，虚拟机加载类包括加载和链接阶段，加载阶段只是把类加载进内存，链接阶段会验证加载的代码的合法性，并初始化静态字段和静态块；shouldBeInitialized 就是检查链接阶段有没有执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clsInitialized</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">    System.out.println(U.shouldBeInitialized(MyObj.class));</span><br><span class="line">    System.out.println(U.shouldBeInitialized(MyObjChild.class));</span><br><span class="line">    U.ensureClassInitialized(MyObjChild.class);</span><br><span class="line">    System.out.println(U.shouldBeInitialized(MyObjChild.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObjChild</span> <span class="keyword">extends</span> <span class="title">MyObj</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> f1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> f2=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        f1=<span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"MyObjChild init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">false</span> </span><br><span class="line"><span class="keyword">true</span> </span><br><span class="line">MyObjChild init </span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>第一行输出 false 是因为我这个代码（包括 main 方法）是在 MyObj 类里写的，执行 main 的时候，MyObj 已经加载并初始化了。调用 U.shouldBeInitialized(MyObjChild.class) 只会加载 MyObjChild.class，但不会初始化，执行 ensureClassInitialized 才会初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clsInitialized2</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">    Field f1=MyObjChild.class.getDeclaredField(<span class="string">"f1"</span>);</span><br><span class="line">    Field f2=MyObjChild.class.getDeclaredField(<span class="string">"f2"</span>);</span><br><span class="line">    <span class="keyword">long</span> f1Offset= U.staticFieldOffset(f1);</span><br><span class="line">    <span class="keyword">long</span> f2Offset= U.staticFieldOffset(f2);</span><br><span class="line">    <span class="keyword">int</span> f1Val=U.getInt(MyObjChild.class,f1Offset);</span><br><span class="line">    <span class="keyword">int</span> f2Val=U.getInt(MyObjChild.class,f2Offset);</span><br><span class="line">    System.out.println(<span class="string">"1.\t"</span>+(f1Val==<span class="number">0</span>));</span><br><span class="line">    System.out.println(<span class="string">"2.\t"</span>+(f2Val==<span class="number">1</span>));</span><br><span class="line">    U.ensureClassInitialized(MyObjChild.class);</span><br><span class="line">    f1Val=U.getInt(MyObjChild.class,f1Offset);</span><br><span class="line">    System.out.println(<span class="string">"3.\t"</span>+(f1Val==<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="keyword">true</span></span><br><span class="line"><span class="number">2</span>.<span class="keyword">true</span> MyObjChild init</span><br><span class="line"><span class="number">3</span>.<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>f1 是 static int，f2 是 final static int，因为 f2 是 final，它的值在编译期就决定了，存放在类的常量表里，所以即使还没有初始化它的值就是 1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取本地指针所占用的字节大小，值为 4 或者 8。其他基本类型的大小由其内容决定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">addressSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The value of &#123;<span class="doctag">@code</span> addressSize()&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ADDRESS_SIZE = theUnsafe.addressSize();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本地内存页大小，值为 2 的 N 次方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">pageSize</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>addressSize 返回指针的大小，32 位虚拟机返回 4，64 位虚拟机默认返回 8，开启指针压缩功能（-XX:-UseCompressedOops）则返回 4。基本类型不是用指针表示的，它是直接存储的值。一般情况下，我们会说在 Java 中，基本类型是值传递，对象是引用传递。Java 官方的表述是在任何情况下 Java 都是值传递。基本类型是传递值本身，对象类型是传递指针的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// random trusted operations from JNI:</span></span><br><span class="line"><span class="comment">/// JNI信任的操作</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 告诉虚拟机定义一个类，加载类不做安全检查，默认情况下，参数类加载器(ClassLoader)和保护域(ProtectionDomain)来自调用者类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span><br><span class="line">                                   ClassLoader loader,</span><br><span class="line">                                   ProtectionDomain protectionDomain);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个匿名类，这里说的和我们代码里写的匿名内部类不是一个东西。</span></span><br><span class="line"><span class="comment"> * (可以参考知乎上的一个问答 https://www.zhihu.com/question/51132462)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, <span class="keyword">byte</span>[] data, Object[] cpPatches);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 分配实例的内存空间，但不会执行构造函数。如果没有执行初始化，则会执行初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">allocateInstance</span><span class="params">(Class&lt;?&gt; cls)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock the object.  It must get unlocked via &#123;<span class="doctag">@link</span> #monitorExit&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 获取对象内置锁(即 synchronized 关键字获取的锁)，必须通过 monitorExit 方法释放锁</span></span><br><span class="line"><span class="comment"> * (synchronized 代码块在编译后会产生两个指令:monitorenter,monitorexit)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorEnter</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlock the object.  It must have been locked via &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #monitorEnter&#125;.</span></span><br><span class="line"><span class="comment"> * 释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorExit</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试获取对象内置锁，通过返回 true 和 false 表示是否成功获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">tryMonitorEnter</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Throw the exception without telling the verifier.</span></span><br><span class="line"><span class="comment"> * 不通知验证器(verifier)直接抛出异常(此处 verifier 具体含义未知，没有找到相关资料)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">throwException</span><span class="params">(Throwable ee)</span></span>;</span><br></pre></td></tr></table></figure>

<p>allocateInstance 方法的测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObjChild</span> <span class="keyword">extends</span> <span class="title">MyObj</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> f1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> f2=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        f1=<span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"MyObjChild init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyObjChild</span><span class="params">()</span></span>&#123;</span><br><span class="line">        f2=<span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"run construct"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clsInitialized3</span><span class="params">()</span> <span class="keyword">throws</span> InstantiationException </span>&#123;</span><br><span class="line">    MyObjChild myObj= (MyObjChild) U.allocateInstance(MyObjChild.class);</span><br><span class="line">    System.out.println(<span class="string">"1.\t"</span>+(MyObjChild.f1==<span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">"1.\t"</span>+(myObj.f2==<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyObjChild init</span><br><span class="line"><span class="number">1</span>.<span class="keyword">true</span></span><br><span class="line"><span class="number">2</span>.<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>可以看到分配对象的时候只执行了类的初始化代码，没有执行构造函数。</p>
<p>来看看最重要的 CAS 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically update Java variable to &lt;tt&gt;x&lt;/tt&gt; if it is currently</span></span><br><span class="line"><span class="comment"> * holding &lt;tt&gt;expected&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if successful</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果变量的值为预期值，则更新变量的值，该操作为原子操作</span></span><br><span class="line"><span class="comment"> * 如果修改成功则返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 Object expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 Object x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically update Java variable to &lt;tt&gt;x&lt;/tt&gt; if it is currently</span></span><br><span class="line"><span class="comment"> * holding &lt;tt&gt;expected&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically update Java variable to &lt;tt&gt;x&lt;/tt&gt; if it is currently</span></span><br><span class="line"><span class="comment"> * holding &lt;tt&gt;expected&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">long</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">long</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这几个方法应该是最常用的方法了，用于实现原子性的 CAS 操作，这些操作可以避免加锁，一般情况下，性能会更好， java.util.concurrent 包下很多类就是用的这些 CAS 操作而没有用锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cas</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">    Field field=MyObj.class.getDeclaredField(<span class="string">"objField"</span>);</span><br><span class="line">    <span class="keyword">long</span> offset= U.objectFieldOffset(field);</span><br><span class="line">    MyObj myObj=<span class="keyword">new</span> MyObj();</span><br><span class="line">    myObj.objField=<span class="number">1</span>;</span><br><span class="line">    U.compareAndSwapInt(myObj,offset,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">"1.\t"</span>+(myObj.objField==<span class="number">2</span>));</span><br><span class="line">    U.compareAndSwapInt(myObj,offset,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">"2.\t"</span>+(myObj.objField==<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="keyword">false</span></span><br><span class="line"><span class="number">2</span>.<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取给定变量的引用值，该操作有 volatile 加载语意，其他方面和 getObject(Object, long) 一样</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">getObjectVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将引用值写入给定的变量，该操作有 volatile 加载语意，其他方面和 putObject(Object, long, Object) 一样</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putObjectVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Volatile version of &#123;<span class="doctag">@link</span> #getInt(Object, long)&#125;  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span>     <span class="title">getIntVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Volatile version of &#123;<span class="doctag">@link</span> #putInt(Object, long, int)&#125;  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putIntVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Volatile version of &#123;<span class="doctag">@link</span> #getBoolean(Object, long)&#125;  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">getBooleanVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Volatile version of &#123;<span class="doctag">@link</span> #putBoolean(Object, long, boolean)&#125;  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putBooleanVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">boolean</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Volatile version of &#123;<span class="doctag">@link</span> #getByte(Object, long)&#125;  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">byte</span>    <span class="title">getByteVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Volatile version of &#123;<span class="doctag">@link</span> #putByte(Object, long, byte)&#125;  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putByteVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">byte</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Volatile version of &#123;<span class="doctag">@link</span> #getShort(Object, long)&#125;  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">short</span>   <span class="title">getShortVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Volatile version of &#123;<span class="doctag">@link</span> #putShort(Object, long, short)&#125;  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putShortVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">short</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Volatile version of &#123;<span class="doctag">@link</span> #getChar(Object, long)&#125;  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">char</span>    <span class="title">getCharVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Volatile version of &#123;<span class="doctag">@link</span> #putChar(Object, long, char)&#125;  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putCharVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">char</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Volatile version of &#123;<span class="doctag">@link</span> #getLong(Object, long)&#125;  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span>    <span class="title">getLongVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Volatile version of &#123;<span class="doctag">@link</span> #putLong(Object, long, long)&#125;  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putLongVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Volatile version of &#123;<span class="doctag">@link</span> #getFloat(Object, long)&#125;  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">float</span>   <span class="title">getFloatVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Volatile version of &#123;<span class="doctag">@link</span> #putFloat(Object, long, float)&#125;  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putFloatVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">float</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Volatile version of &#123;<span class="doctag">@link</span> #getDouble(Object, long)&#125;  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">double</span>  <span class="title">getDoubleVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Volatile version of &#123;<span class="doctag">@link</span> #putDouble(Object, long, double)&#125;  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putDoubleVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这是具有 volatile 语意的 get 和 put方法。volatile 语意为保证不同线程之间的可见行，即一个线程修改一个变量之后，保证另一线程能观测到此修改。这些方法可以使非 volatile 变量具有 volatile 语意。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * putObjectVolatile(Object, long, Object)的另一个版本(有序的/延迟的)，它不保证其他线程能立即看到修改,</span></span><br><span class="line"><span class="comment"> * 该方法通常只对底层为 volatile 的变量(或者 volatile 类型的数组元素)有帮助</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putOrderedObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Ordered/Lazy version of &#123;<span class="doctag">@link</span> #putIntVolatile(Object, long, int)&#125;  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putOrderedInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Ordered/Lazy version of &#123;<span class="doctag">@link</span> #putLongVolatile(Object, long, long)&#125; */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span>    <span class="title">putOrderedLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>有三类很相近的方法：putXx、putXxVolatile 与 putOrderedXx：</p>
<ul>
<li>putXx 只是写本线程缓存，不会将其它线程缓存置为失效，所以不能保证其它线程一定看到此次修改；</li>
<li>putXxVolatile 相反，它可以保证其它线程一定看到此次修改；</li>
<li>putOrderedXx 也不保证其它线程一定看到此次修改，但和 putXx 又有区别，它的注释上有两个关键字：顺序性（Ordered）和延迟性（lazy），顺序性是指不会发生重排序，延迟性是指其它线程不会立即看到此次修改，只有当调用 putXxVolatile 使才能看到。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放当前阻塞的线程。如果当前线程没有阻塞，则下一次调用 park 不会阻塞。这个操作是"非安全"的</span></span><br><span class="line"><span class="comment"> * 是因为调用者必须通过某种方式保证该线程没有被销毁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞当前线程，当发生如下情况时返回：</span></span><br><span class="line"><span class="comment"> * 1、调用 unpark 方法</span></span><br><span class="line"><span class="comment"> * 2、线程被中断</span></span><br><span class="line"><span class="comment"> * 3、时间过期</span></span><br><span class="line"><span class="comment"> * 4、spuriously</span></span><br><span class="line"><span class="comment"> * 该操作放在 Unsafe 类里没有其它意义，它可以放在其它的任何地方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br></pre></td></tr></table></figure>

<p>阻塞和释放当前线程，java.util.concurrent 中的锁就是通过这两个方法实现线程阻塞和释放的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *获取一段时间内，运行的任务队列分配到可用处理器的平均数(平常说的 CPU 使用率)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getLoadAverage</span><span class="params">(<span class="keyword">double</span>[] loadavg, <span class="keyword">int</span> nelems)</span></span>;</span><br></pre></td></tr></table></figure>

<p>统计 CPU 负载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The following contain CAS-based Java implementations used on</span></span><br><span class="line"><span class="comment">// platforms not supporting native instructions</span></span><br><span class="line"><span class="comment">//下面的方法包含基于 CAS 的 Java 实现，用于不支持本地指令的平台</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在给定的字段或数组元素的当前值原子性的增加给定的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 字段/元素所在的对象/数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset 字段/元素的偏移</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta 需要增加的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 原值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAddLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getLongVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapLong(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将给定的字段或数组元素的当前值原子性的替换给定的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 字段/元素所在的对象/数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset field/element offset</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newValue 新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 原值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//举个例子，比如 i++ 这个操作，它不是原子性的，而是分为两步：</span></span><br><span class="line"><span class="comment">//1.先获取 i 的值</span></span><br><span class="line"><span class="comment">//2.对 i 加 1</span></span><br><span class="line"><span class="comment">//所以为了保证原子性，CAS 在第二部操作的时候，会先判断当前要修改的值，是否等于预期值：</span></span><br><span class="line"><span class="comment">//1.如果等于则直接修改</span></span><br><span class="line"><span class="comment">//2.如果不等于，则重新拿一个新的预期值，在和要修改的当前值比较(只有符合预期值，才能修改，否则说明已经被其他线程修改，那么当前线程需要重新拿一次属于自己的预期值)。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, newValue));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndSetLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getLongVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapLong(o, offset, v, newValue));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">getAndSetObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object newValue)</span> </span>&#123;</span><br><span class="line">    Object v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getObjectVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapObject(o, offset, v, newValue));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于 CAS 的一些原子操作实现，也是比较常用的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确保该栏杆前的读操作不会和栏杆后的读写操作发生重排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">loadFence</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确保该栏杆前的写操作不会和栏杆后的读写操作发生重排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">storeFence</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确保该栏杆前的读写操作不会和栏杆后的读写操作发生重排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">fullFence</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抛出非法访问错误，仅用于VM内部</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">throwIllegalAccessError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是实现内存屏障的几个方法，类似于 volatile 的语意，保证内存可见性和禁止重排序。这几个方法涉及到 JMM（Java 内存模型），有兴趣的可参考Java <a href="http://ifeve.com/jmm-cookbook-mb/" target="_blank" rel="noopener">内存模型 Cookbook 翻译</a> 。</p>
<h4 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h4><blockquote>
<p>以下补充，是原文章评论区的一条评论</p>
</blockquote>
<ol>
<li>JDK11包含了Unsafe源码,内部实现转移到jdk.internal.misc这个包里,仍然属于半开放状态,提供的方法可能随时修改.</li>
<li>JDK11的Unsafe大部分方法都带@HotSpotIntrinsicCandidate注解,说明会被直接映射成机器指令,而不是方法调用. 还有些方法用了@ForceInline注解,能保证被内联优化.</li>
<li>文中提到的几个@Deprecated方法在JDK11里不是删除了就是原型改变了(主要是offset变成了long类型)</li>
<li>“narrow类型”估计是指数组中的每个元素占用不到1个字节的情况, 目前所见的JDK实现没有这种情况, 估计有的JDK把boolean数组中的每个元素只用1 bit来实现的.</li>
<li>“Java 官方的表述是在任何情况下 Java 都是值传递。基本类型是传递值本身，对象类型是传递指针的值。”我完全赞同这种说法,非常清晰准确,我觉得严格的”引用”含义应该像C++中的”&amp;”和C#中的”ref/out”这种变量本身的别名(就是说Java对象的引用应该是指针的指针).</li>
<li>“不通知验证器(verifier)直接抛出异常”应该是指可以绕过throws声明.</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在此感谢作者的输出，在学并发类时，Unsafe 类是非常底层的类，但是其中的方法几乎都是 native 的，所以一时无从下手，即使看了源码的注解。所以特此记录了此文章，方便日后翻阅查看。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JUC/" rel="tag"># JUC</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/29/OM/docker基础学习笔记/" rel="next" title="docker基础学习笔记">
                <i class="fa fa-chevron-left"></i> docker基础学习笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/12/concurrent/AtomicInteger源码学习/" rel="prev" title="AtomicInteger源码学习">
                AtomicInteger源码学习 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">R.D</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
<br>

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#简述"><span class="nav-number">1.</span> <span class="nav-text">简述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#源码分析"><span class="nav-number">2.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一些补充"><span class="nav-number">3.</span> <span class="nav-text">一些补充</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">R.D</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
